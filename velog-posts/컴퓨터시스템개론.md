<ul>
<li><p>ICT 기술(정보통신기술): IT(정보기술) + CT(통신기술)  _정보 기기의 HW,SW를 이용해 정보를 다루는 모든 방법임 (수집,생산,가공,보존,전달…) / 컴퓨터 하드웨어, 소프트웨어, 네트워크 통신, 정보를 융합적으로 활용하는 기술</p>
</li>
<li><p>정보 사회</p>
</li>
</ul>
<p>: ICT 기술의 발달로 정보의 양이 많아져 모든 업무의 중심이 정보 활용이 되고, 정보가 부 창출의 원천이 되는 사회  / 대니얼 벨, 앨빈 토플러 / 20세기 말 인터넷의 보급으로 정보 사회가 고도화됨 / 21세기에는 정보사회를 넘어 4차 산업혁명 시대로 돌입
정보는 자료(data)를 가공한 것임 ex) 소비목룍-자료, 소비패턴-정보</p>
<p>1차 산업혁명_18세기 영국,증기기관,제조업(기계를 사용)경제로 전환됨 / 2차 산업혁명_19세기,전기,컨베이어벨트,자동화,대량생산 / 3차 산업혁명_컴퓨터,디지털화,현재도 지속중 / 4차 산업혁명_21세기,디지털기술(인공지능,IoT,빅데이터,3D프린터),획기적인 기술 진보,산업 재편,전반적 시스템 변화</p>
<ul>
<li><p>컴퓨터 == 전자회로를 이용해 다양한 종류의 데이터를 처리하는 기계==HW+SW
특징: 신속성, 정확성, 자동성, 대량성
컴퓨터의 추상화: 복잡한 시스템을 단계별로 단순화함 / 프로그래머들이 세부적인 사항에 신경쓰지 않고 핵심에만 집중할 수 있도록 도움 </p>
</li>
<li><p>컴퓨터의 역사</p>
</li>
</ul>
<p>ㅁ기계식 계산기의 역사</p>
<p>신체_단위가 뼘,길,발 / 돌, 나무조각 / 주판_한국식-5진법,10진법 동시에 사용 가능, 중국식 16진법 / 
(기계식)
17-19C: <strong>파스칼</strong>-<strong>톱니바퀴</strong>를 이용한 <strong>최초의 기계식 수동 계산기</strong>, 10진법 / 라이프니츠-사칙연산기 / 배비지-다항함수를 계산할 수 있는 차분기관, 더 일반적인 계산이 가능한 해석기관 설계_펀치카드에 기반, 컴퓨터의 요소인 기억장치,연산및제어장치,입출력장치로 이뤄져 있음</p>
<p>18-19C: 증기기관, 천공카드(새로운 입력 시스템)_1차 산업혁명, 2진법 / <strong>튜링머신</strong>_컴퓨터라고 가정할 수 있는 <strong>기계 실행</strong>과, <strong>데이터 저장</strong>을 할 수 있는 추상적인 계산 모델 </p>
<p>+앨런 튜링 - 튜링 머신, 튜링 테스트_컴퓨터가 사람과 같은 지능을 갖고있는지 검사, CAPTCHA_튜링 테스트를 <strong>자동화</strong>,사람과 컴퓨터를 구분</p>
<p>ㅁ전자식 컴퓨터의 개발_전기를 사용해 동작하는 컴</p>
<p>ABC_선형 방정식 해결을 위한 <strong>최초의 전자식 컴퓨터</strong> / 마크원<em>전기 기계식임, <strong>배비지의 해석기관</strong>이 실제로 구현된 기계, 릴레이 이용(전자석 기반 부품) / <strong>애니악</strong>_1946, <strong>다용도</strong> 전자식 컴퓨터, <strong>진공관(전력 소모가 크고 열을 많이 발생시켜 냉각장치가 필요해 컴 크기가 커짐)</strong>, <strong>외부 프로그래밍</strong> 방식,10진법(진공관을 사용하긴하지만 내부적인 처리엔 2진법을 묶어 10진법 사용) / <strong>내장형 프로그램 방식</strong> 구현됨-폰 노이만</em><em>애니삭,애드박에 들어감(얘네도 진공관은 사용)</em>  / 유니박_최초의 상용 컴 /  트랜지스터, 직접회로(IC)(여러 트랜지스터를 하나의 칩에 직접함)의 개발로 컴 크기 작아지고 속도 빨라짐 / 개인용 컴퓨터 등장 _<strong>초직접회로</strong>(초고밀도직접회로)의 개발로 가능해짐</p>
<p>ㅁ인터넷_미국 국방성, 모바일 컴퓨팅_1인 다 컴퓨터 시대, 기반기술:고속 네트워크_고속의 네트워크 전송 기술, 모바일 hw_초경량,초소형 하드웨어 제조 기술, 모바일 sw_개인에게 최적화된 소프트웨어의 제작과 유통 기술,  컴퓨터를 구성하는 기본 소자가 소형화, 고속회됨</p>
<ul>
<li>컴의 종류</li>
</ul>
<p>ㅁ슈퍼 컴퓨터 : 고속도 고용량 / <strong>과학 기술 계산</strong> / <strong>병렬 처리(여러 CPU 연결)</strong> / <strong>성능단위</strong>_FLOPS(1초당 실행되는 부동소수점 연산 개수의 단위) / 기준_연산처리속도 순위가 세계 500위 안에 드는 컴</p>
<p>ㅁ메인프레임 : 대형컴퓨터 / 대용량, 고속처리 / 다수의 사용자가 함께 쓸 수 있음 / 연구소, 기업, 은행 등에서 사용</p>
<p>ㅁ워크스테이션 : 대형과 개인용 컴의 사이인 중형 컴퓨터 / 다수의 사용자가 단말기를 통해 사용가능 / 과학기술 분야 연구개발용</p>
<p>ㅁ개인용 컴퓨터 : ==마이크로 컴퓨터, 데스크톱</p>
<p>ㅁ휴대용 컴퓨터 : 노트북, 폰, 태블릿</p>
<p>+임베디드 컴  : 시스템(내비게이션, 폰)에 내장된 소형 컴퓨터_아두이노, 라즈베리파이 </p>
<ul>
<li>미래 컴퓨팅 기술</li>
</ul>
<p>ㅁ클라우드 컴퓨팅 : <strong>인터넷 서버</strong>를 통해 ICT 기술 관련 서비스(데이터 저장, 네트워크, 콘텐츠 사용)를 <strong>동시에 사용할 수 있게 하는 컴퓨팅 환경</strong> / 데이터가 기기 자체에 저장된 게 아니라, 인터넷 서버에 영구적으로 저장됨(hw에 의존하지 않아도 됨) / 저비용, 유연성, 관리 용이성 </p>
<p>(클라우드 서비스 모델)
SaaS _서비스형 sw: 공급업체가 모두 제공 / 특정 앱|웹 을통해 접근하는 서비스 / 클라이언트에세 제공되는 완전한 sw        icloud, Google Drive, 기업용 메신저, 넷플릭스</p>
<p>IaaS _서비스형 인프라: 애플리케이션과 서비스를 제공하는 데 필요한 핵심 인프라를 제공               AWS, Rackspace</p>
<p>ㅁ사물 인터넷 : 각종 기기에 칩을 내장해 무선통신으로 인터넷과 연결하는 기술 / 핵심 기술_센싱 기술, 보안 기술, 유무선 통신기술, 서비스 인터페이스 기술</p>
<p>ㅁ인공지능 : 여러 학문에 기초해 인간과 동일한 작업을 할 수 있는 기계를 만드는 과학 기술</p>
<h3 id="컴퓨터의-구성요소">컴퓨터의 구성요소</h3>
<figure>
    <img src="https://velog.velcdn.com/images/kimlj0814/post/f6c12429-3cd3-40db-b87a-a242bbe8de4e/image.png" title="응용 sw~hw 관계" />    
    <figcaption>응용 sw~hw 관계</figcaption>
</figure>

<h4 id="하드웨어">하드웨어</h4>
<p>: 컴퓨터 시스템을 구성하는 기계장치 / 입력장치, 출력장치, 중앙처리장치(CPU), 기억장치 /  각 장치는 시스템 버스로 연결돼 있음 
컴퓨터 구조: <strong>하드웨어를 구성</strong>하는 각 장치의 특성, 동작 원리를 다루는 학문</p>
<p>ㅁ 기억장치
: 데이터와 프로그램을 저장하는 장치</p>
<p>(성능에 따라 분류)
레지스터, 캐시 메모리, 주기억장치, 보조기억장치</p>
<figure>
    <img src="https://velog.velcdn.com/images/kimlj0814/post/dd0e30b7-9dd6-47bf-936b-e1ba4d2c4263/image.png" title="응용 sw~hw 관계" />    
    <figcaption>기억장치를 계층으로 나눈 이유는 전체 비용을 고려해 용량과 접근 속도를 최적화하기 위해서임</figcaption>
</figure>

<p>o 주기억장치(main|primary memory)
: 작업에 필요한 프로그램과, 프로그램이 이용할 자료를 임시로 저장하기 위한 장치 </p>
<p>비트 단위의 메모리가 모여 <strong>바이트 단위로 구성됨</strong>
<img height="30%" src="https://velog.velcdn.com/images/kimlj0814/post/c1397ba9-9412-4f88-8941-ab688702a6a2/image.png" width="50%" />
(RAM 과 ROM 으로 구분됨)</p>
<ul>
<li>RAM(임의 접근 메모리) == 메인메모리</li>
</ul>
<p>메모리의 임의의 위치에 정보를 <strong>쓰고, 읽</strong>을 수 있음 <em>Random Access: <strong>주소</strong>를 지정하면 어느 데이터든 동일한 접근 속도로 사용할 수 있다는 의미 (주소 기반 접근</em>)</p>
<p>전원이 끊기면 저장된 내용이 지워지는 <strong>휘발성 메모리</strong></p>
<p>DRAM_일정 시간이 지나면 저장된 데이터가 사라짐(주기적으로 다시 재생 필요) / SRAM_전원만 연결돼 있으면 데이터 계속 보관 가능, 캐시 메모리에 사용</p>
<p>-ROM(읽기 전용 메모리)</p>
<p>한 번 저장된 자료는 <strong>읽기만 가능</strong>(쓰기 x)</p>
<p><strong>비휘발성 메모리</strong>, random access도가능 </p>
<p>컴이 전원 공급을 받아 처음 수행해야 하는 프로그램(부트프로그램) 저장에 사용</p>
<p>o 보조기억장치: cpu가 처리할 데이터나 프로그램을 저장하는 장소</p>
<p>o 캐시 메모리 (associate memory)</p>
<p>:  cpu와 메인메모리의 중간에 위치해, 둘의 성능차이를 보완 = 데이터 접근 효율성up (reg와 RAM 의 속도 차로 자료이동이 느림→reg와 캐시메모리간의 자료 이동으로 처리속도 up) → 컴의 처리 속도 향상</p>
<p>메인 메모리보다 크기는 작음 , 성능은 더 좋음</p>
<figure>
    <img src="https://velog.velcdn.com/images/kimlj0814/post/fcf453d2-5da1-4436-8032-61fe3f769405/image.png" />    
    <figcaption>데이터의 메인메모리에서의 주소인 테그도 가짐 </figcaption>
</figure>
캐시 메모리의 동작 과정

<ol>
<li>cpu가 메인메모리의 데이터를 읽어야 할 때 먼저 캐시메모리를 조사함</li>
<li><strong>캐시메모리에 있으면 바로 cpu로 전달됨</strong></li>
<li>없으면 메인메모리에서 캐시메모리를 통해 cpu로 전달됨 </li>
</ol>
<p>캐시 적중: cpu에서 원하는 정보가 캐시에 있는 상황</p>
<p>캐시 미스: ” 없는 상황</p>
<p>캐시 적중률(H): 원하는 정보가 캐시 메모리에 있을 확률 / 캐시 적중률이 높아야 캐시 메모리를 사용하는 의미가 있음</p>
<p>= 캐시 적중 횟수 / 전체 기억장치 참조 횟수</p>
<p>평균 메인메모리 접근 시간 (캐시 적중률 고려)</p>
<p>= (H * 캐시 접근 시간) + ((1-H)*(메인메모리 접근 시간+캐시 접근 시간))</p>
<p>o 운영체제의 메모리 관리</p>
<p> <strong>메인메모리 관리</strong>
 <div style="width: 55%; height: 320px; float: left;">
단일 프로그래밍: 운영체제 외 하나의 사용자 프로그램만 저장하는 방식, RAM에 하나의 프로그램만 저장해 실행 가능</p>
<p>사용자 프로그램을 메모리 주소 시작 부분에 두면 <strong>os</strong>는 사용자 프로그램이 os를 침범하지 않도록 막기만 하면 됨</p>
<p><strong>os의 역할이 단순</strong>해 구현이 쉽지만, <strong>cpu를 효율적으로 사용할 수 없음</strong></p>
</div>
<div style="width: 45%; height: 320px; float: right;">
    <img src="https://velog.velcdn.com/images/kimlj0814/post/8c431716-9c27-41c5-88d1-a628f85fb5bf/image.png" />  
</div>

<p>-<strong>다중 프로그래밍</strong>: 메인메모리에 여러 작업을 쌓아 두고, cpu가 작업을 오가며 조금씩 수행하는 방식== 하나의 cpu를 2개 이상의 프로그램(프로세스)이 시분할 방식으로 사용하는 <strong>병행처리 작업(멀티 쓰레딩) &amp;&amp; (실제로는)</strong> 하나의 cpu에 코어가 여러개이므로 <strong>병렬 처리 작업도 함</strong></p>
<p>+병행처리 / 병렬처리 차이점: 병행처리는 여러 작업이 동시에 실행되는 것처럼 보이는 것이고, 병렬처리는 실제로 여러 프로세서가 작업을 동시에 처리하는 것임</p>
<p>메인메모리 관리 기법, cpu 스케줄링 기법이 필요함 //os는 프로그램들이 서로 충돌하거나 영역을 침범하지 않도록 관리함 </p>
<p>ㄴ메인메모리 관리 기법으로 고정 분할 메모리 관리 / 가변 분할 메모리 관리가 있음 (물리적 메모리의 한곳에 연속적으로 적재하는 연속 할당 방식임)
 <div style="width: 55%; height: 400px; float: left;">
ㄴ<strong>고정 분할 메모리 관리 기법</strong></p>
<p>컴퓨터가 부팅할 때 <strong>분할된 메모리 구조를 유지</strong>하다가(영구적인 분할), 프로그램이 실행되면 <strong>작업에 적당한 위치를 할당하는 방식</strong></p>
<p>작업 순서대로 로딩!!!!</p>
<p>단편화 : 작업량과 분할 공간의 크기가 일치하지 않아 <strong>빈 공간이 발생하는 것</strong></p>
<pre><code>내부 단편화: 작업물이 분할 공간에 들어가 있지만 공간의 크기가 커서 빈 공간이 발생
외부 단편화: 분할 공간의 크기가 작업량보다 작아 빈공간이 발생 //작업을 로딩하지 못함</code></pre></div>
<div style="width: 45%; height: 400px; float: right;">
  <figure>
    <img src="https://velog.velcdn.com/images/kimlj0814/post/dc40c5a3-7ae7-4a48-88ee-379dbfa6d454/image.png" />  
    <figcaption>분할 공간은 하나의 작업이 쌓일 수 있는 일정한 크기의 기억 공간이므로, 다른 프로세스가 침범하지 않도록 보호돼야함, 이를 위해 상한 주소, 하한주소 값이 저장된 레지스터를 사용</figcaption>
  </figure>
</div>
<p align="center">
<img src="https://velog.velcdn.com/images/kimlj0814/post/1d54dfff-2ac0-4b4d-9c74-b36875345d12/image.png" width="80%" />
</p>
ㄴ**가변 분할 메모리 관리 기법**

<p>고정 분할 메모리 관리 기법의 단점을 보완하기 위해 등장 (공간 낭비)</p>
<p>고정된 분할 공간의 경계를 없애고 <strong>작업량에 따라 메모리를 알맞은 크기로 분할해 할당하는 방식</strong> </p>
<p>빈 공간을 하나로 만들기 위해 프로세스를 재배치하는 <strong>압축 과정</strong> 실행, 합쳐진 공간은 다음에 실행될 프로세스가 사용함 //항상 가능하진 않음</p>
<p>내부 단편화는 생기지 않지만 외부 단편화는 생길 수 있음
<img src="https://velog.velcdn.com/images/kimlj0814/post/295503fc-9ed7-4b75-9c6e-0409d5635eb3/image.png" width="80%" />
<strong>빈 공간에</strong> 새 프로그램을 할당하는 방식 3가지</p>
<p>최초 적합: 프로그램 크기보다 큰 분할 공간 중 처음 만나는 공간을 할당
최적 적합: 프로그램 크기보다 큰 분할 공간 중 가장 딱 맞는(작은) 공간을 할당
최악 접합: 프로그램 크기보다 큰 분할 공간 중 가장 큰 공간을 할당 </p>
<p>+물리주소_메인메모리가 사용 / 논리주소_cpu가 사용</p>
<p>o 가상 메모리 관리</p>
<p>(보조기억장치에서 주기억장치로 프로그램을 옮겨야 실행할 수 있는데, 주기억장치 내 저장공간이 부족하면 프로그램이 제대로 실행되지 못함)
: 당장 실행해야 하는 <strong>부분</strong>(cpu에 의해 실제로 사용되는 부분)만 메인메모리에 저장하고 나머지 부분은 보조기억장치에 둔채 동작하는 방식</p>
<p>(구현방법)
페이징 기법: 프로그램을 일정 크기로 나눠 페이지를 만들고 페이지 단위별로 메인메모리에 올려 동작하는 방식
== 가상 메모리를 일정한 크기의 페이지로 나눠 관리하는 것임
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/a90592e1-799c-45fd-a3f9-d7ad4a432bec/image.png" />
페이지가 메인메모리에 올라가면 프레임이라 함 </p>
<p>각 프로세스에 <strong>페이지 테이블</strong>이 할당돼 페이지와 프레임 번호를 연결해줌</p>
<p>ㄴ페이지 테이블은 각각의 페이지가 몇 번 프레임에 있는지(해당 프레임이 있는 메인메모리 주소) 저장 </p>
<p>+요구 페이징 기법: 페이징 기법+cpu가 메모리에 없는 페이지도 보조기억장치에서 갖다씀</p>
<p>+세그멘테이션 기법: 프로그램을 페이지가 아닌 논리적인 단위(코드, 테이터,스택…)로 잘라서 메모리에 적재</p>
<p>입력장치: 자료(데이터) 를 컴 내부로 입력</p>
<p>키보드, 마우스, 스캐너, 마이크, 조이스틱, 스타일러, 동작 인식 기기(키넥트_몸동작, 립모션_손동작) </p>
<p>출력장치: 컴퓨터의 처리 결과를 적당한 형태로 바꿔 출력</p>
<p>프린터, 모니터, 스피커</p>
<p><strong>(입출력 장치의 제어방식)</strong></p>
<p>o CPU를 통한 제어:</p>
<p>-프로그램에 따른 방법 : 현재 실행되는 프로그램이 입출력의 전 과정을 직접 수행(모든 과정을 cpu가 담당→cpu 효율 down)</p>
<p>I/O 작업시 cpu는 이 작업에만 관여해야 해 <strong>다른 작업을 할 수 없는 단점</strong>이 있음 </p>
<p>-인터럽트에 따른 방법 : 프로그램에 따른 방법의 비효율성(cpu 독점)을 극복한 방법 / I/O 명령이 발생하면 프로세스가 실행에서 대기 상태로 이동, cpu는 작업을 전환함, <strong>I/O가 완료되면(프로세스는 준비 상태) cpu에게 인터럽트 신호를 보냄</strong>, <strong>cpu는 관련 ISR을 수행해 입출력 과정을 종료함</strong> (cpu가 입출력을 기다리지 않고 다른 작업으로 전환해 효율 up) / 현재 사용</p>
<p><strong>입출력 명령이 시작되는게 인터럽트가 아님!!!! (cpu가 입출력 시작을 명령하고 작업을 전환하는 건 그냥 명령어를 실행하는 것임)</strong> </p>
<p>o DMA방식(Direct Memory Access)을 통한 제어: <strong>cpu 활용 X,</strong> 입출력장치 제어기는 cpu로부터 입출력 관련 사항을 모두 위임받음 / <strong>입출력장치와, 메인메모리 사이의 데이터 통신</strong>으로 입출력 제어를 수행해 cpu의 효율성을 더 높일 수 있음, 속도 up, 대량의 데이터 입출력 가능</p>
<p>ㅁ <strong>중앙처리장치 CPU==processor</strong></p>
<p>: 프로그램(sw)의 명령어와 데이터를 처리하는 장치 </p>
<p>메모리에서 필요한 프로그램과 자료(데이터)를 이용함, 저장된 명령어를 순차적으로 해독하고 실행 </p>
<p>+이전의 컴들은 작업할 때마다 전기회로를 바꿔야했지만(에니악-하드와이어드 프로그래밍) 프로그램 내장 방식은 주기억장치에 프로그램만 바꿔 저장하면 원하는 프로그램 실행 가능 , 애니삭에 처음 적용됨 </p>
<p>o <strong>폰 노이만 - 프로그램 내장 방식(</strong>지금 컴은 <strong>폰 노이만 구조)</strong>  : 주기억장치에 자료, 프로그램도 내장하는 방식 / 하드웨어는 그대로 둔 채 주기억장치에서 프로그램만 교체해 실행하는 방식 / 컴 부품이 버스(외부 버스)로 연결돼 있는 형태 / 모든 프로그램이 주기억장치에 올라와야 실행이 가능한 구조 </p>
<p>프로그래밍: 하드웨어의 전선 연결 → 컴 내부에 저장돼 구현</p>
<p>(3개의 모듈로 구성)</p>
<p>o 연산장치 ALU</p>
<p>실제 연산을 담당하는 <strong>회로</strong> (산술연산, 논리연산) </p>
<p>+자리올림이 발생하지 않으면 논리연산이 더 빠름</p>
<p>제어장치의 신호를 받아 연산 실행</p>
<p>o 제어장치 CU</p>
<p>수행할 명령어를 해독하고 실행되도록 제어하는 장치</p>
<p>cpu 내부 모듈(연산장치, 레지스터), 외부 장치(메모리, 입출력장치)에 명령 수행 신호(제어신호)를 보냄=<strong>컨트롤 타워 역할</strong> </p>
<p>o 레지스터</p>
<p>cpu와 속도가 비슷한 고속의 기억장치  /  cpu 내부의 기억장치 </p>
<p>주기억장치에 있는 <strong>연산에 필요한 데이터</strong>를 임시로 저장하는 공간</p>
<p>cpu 내부에 여러개의 레지스터를 가짐, 그 크기와 수는 cpu 성능에 매우 중요한 요소임</p>
<p>-내부버스(시스템 버스) : data bus_레지스터 - 연산장치 / control bus_제어장치 - 레지스터,연산장치 (명령제어 신호를 전달하는 경로)</p>
<p>-<strong>명령어 처리과정</strong> : RAM의 명령어, 자료를 CPU의 레지스터로 전송 → 명령어 처리 → 처리결과인 정보가 RAM으로 다시 전달됨 / <strong>CPU와 RAM의 자료 교환</strong> </p>
<p>+cpu의 <strong>명령어 수행 사이클</strong>:</p>
<div style="width: 55%; height: 750px; float: left;">

<ol>
<li>인출(Fetch) </li>
</ol>
<p>수행할 명령어를 <strong>주기억장치</strong>에서 가져와 cpu 내부의 프로그램 카운터 레지스터(PC)의 주소로 명령어 레지스터(IR)에 저장함    </p>
<ol start="2">
<li>해독(Decode) </li>
</ol>
<p>인출된 명령어의 종류를 해독함(IR의 내용을 해독)</p>
<p>연산 부분(어떤 명령어인지), 피연산 부분으로      <strong>CU</strong></p>
<ol start="3">
<li>실행(Excute)</li>
</ol>
<p>제어장치가 <strong>명령어 해독 결과에 적합한 제어신호를 제어버스로 전송</strong>하면 명령어가 실행됨(CPU내 구성요소에게 작업 지시를 내림)      <strong>ALU</strong></p>
<p>단계를 나눠 놓으면 <strong>병렬 처리</strong>가 가능해 속도 up //cpu가 여러개인 것 같은 효과 </p>
<p>프로그램이 실행되려면 명령어 수행 사이클을 계속 반복해야함</p>
</div>
<div style="width: 45%; height: 750px; float: right;">
    <img src="https://velog.velcdn.com/images/kimlj0814/post/f014c984-54ec-497e-84dd-268e825137ad/image.png" />  
</div>
- CPU의 형태

<p>CISC 구조 : 
명령어의 종류가 다양(길이 등)하고 많음 / 복잡한 연산을 적은 명령어로 처리하려는 의도</p>
<p>RISC : 
명령어의 종류가 적고, 구조도 단순해 (명령어의 수행시간, 용량을 비슷하게 해) 병렬처리가 용이함 → CISC구조보다 속도가 빠름</p>
<p>-관련 용어</p>
<p>클록: 컴에서 <strong>일정한 박자</strong>를 만들어 내는 장치, 일정한 간격으로 만드는 틱을 ‘펄스’라고 함
클록 펄스: 컴 구성요소의 동작을 <strong>동기화</strong>하기 위해 사용하는 <strong>전자적 펄스</strong></p>
<p>컴의 모든 부품은 클록 신호에 맞춰 동작함, 통신 속도 설정에도 사용됨 / 클록 속도가 높으면 단위시간당 처리하는 명령어 개수up-컴 속도up (멀티코어의 등장으로 클록의 속도보다 컴퓨터의 병렬화가 중요해짐)</p>
<p>인터럽트: cpu가 특정 기능 수행 중 급하게 다른 일을 처리하고자 할 때 사용하는 기능 _다중 프로그래밍(시분할)</p>
<p>작업 중 인터럽트가 발생하면 중지하고 현재 상태를(cpu 내부의 레지스터 값) 등을 따로 보관함 / ISR(인터럽트 서비스 루틴)을 수행해 인터럽트가 처리되면 저장했던 이전 작업의 상태를 복구시켜 수행을 재개 </p>
<p>종류: 입출력 인터럽트_입출력 종료 등의 이유로 cpu 수행을 요청하는 인터럽트  /  소프트웨어 인터럽트 _cpu가 명령을 수행하는 중간에 소프트웨어가 발생시키는 인터럽트</p>
<p>ㅁ 시스템 버스</p>
<div style="width: 55%; height: 750px; float: left;">

<p>: 중앙처리장치, 주기억장치, 입출력장치 간 <strong>데이터를 주고받기 위한 경로</strong> </p>
<p>대역폭이 넓을 수록 
한 번에 전송할 수 있는 데이터양&amp;&amp;전송속도&amp;&amp;시스템 성능&amp;&amp;주기억장치 용량up</p>
<p>o 데이터 버스  data bus
cpu와 다른 장치 | cpu 내부 모듈 사이에서 데이터가 이동하는 경로 </p>
<p>o 주소 버스  address bus
cpu가 사용하고자 하는 <strong>데이터의 주소</strong>가 이동하는 경로</p>
<p><strong>주소 버스의 대역폭</strong>(비트수)이 <strong>주기억장치의 용량</strong>을 결정함 _ 32bit 컴은 4G<strong>B</strong>까지 / 64bit 컴은 16E<strong>B</strong> 까지 RAM 용량이 증가 가능 (기억장소의 단위는 바이트|워드)</p>
<p>o 제어 버스   control bus
cpu에서 발생하는 제어 명령, 상태 신호를 전달하는 통로 (입출력 동기화신호, 인터럽트 관련 신호…)</p>
</div>
<div style="width: 45%; height: 750px; float: right;">
    <img src="https://velog.velcdn.com/images/kimlj0814/post/c988bfe4-f568-4f5a-b9fd-2b39f395119f/image.png" />  
</div>
+메인보드 : 컴 부품(프로세서, 메모리, 주변장치들…)을 연결시켜 주는 판, 선들이 버스임 
+포트: 메인 보드에 있는 각종 부품을 꽂을 수 있는 단자 / 컴과 외부 다른 장비를 연결하는 통로 / 직렬 포트와 병렬 포트가 있음

<p>+병렬 컴퓨터</p>
<p>: <strong>다수의 cpu</strong>를 <strong>병렬 처리</strong>해 고속으로 작업을 수행하는 컴퓨터</p>
<p>어려운 cpu 소형화 대신 사용하게 됨 (발열문제)</p>
<p>-병렬 처리 : 동시에 동작하는 cpu를 여러 대 갖춘 컴퓨터에서만 실행 가능한 방식</p>
<p>(명령어 스트림, 데이터 스트림을 처리하는 방식에 따라) </p>
<p>o SISD : 단일 cpu _하나의 프로그램 수행시, 하나의 데이터 이용 / 일반 개인용 컴의 cpu구조</p>
<p>o SIMD : cpu들이 같은 프로그램(명령어)를 수행하는데 병렬적으로는 다른 데이터를 처리하는 구조, 가장 일반적인 병렬 연산 기법</p>
<p>o MIMD : 각각의 cpu가 서로 다른 프로그램과 다른 데이터를 처리하는 구조 _다양한 연산을 동시에 할 수 있음</p>
<p>-병렬컴퓨팅 환경 _규모에 따라</p>
<p>(소규모 멀티코어 환경)
<strong>멀티코어 CPU</strong> _2개 이상의 코어(기억 소자)를 탑재한 cpu _여러 cpu를 장착한 것과 유사한 성능 / GPGPU_GPU로 병렬 컴퓨팅, CUDA </p>
<p>(대규모 병렬 컴퓨팅 환경)
o 클러스터 : 여러 컴퓨터를 <strong>랜선</strong>으로 연결해 <strong>하나의 컴처럼 사용</strong>
o 그리드 : <strong>광역 네트워크</strong>에 연결된 여러 컴에 데이터를 전송해 연산하게 한 후, <strong>서버에서 취합해 전체 연산을 수행</strong> _컴들이 여러 곳에 있음</p>
<p>⇒ 하나의 작업을 나눠 수행하는 것임</p>
<h4 id="소프트웨어">소프트웨어</h4>
<p>: 명령어들의 집합(프로그램)과 프로그램 수행에 필요한 절차, 규칙, 관련문서 등을 총칭하는 용어 / 시스템 sw, 응용 sw</p>
<p>+펌웨어: ROM 에서 하드웨어를 제어 역할을 하는 작은 규모의 sw 
+미들웨어: 두 sw 사이에서 중개 역할을 하는 sw
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/29583d3d-2dfa-4c73-aa7d-b652f2bf696b/image.png" /></p>
<ul>
<li>시스템 소프트웨어(운영체제)</li>
</ul>
<p>: 컴퓨터를 관리하기 위한 sw / 컴 사용에 꼭 필요한 프로그램들 / <strong>hw와 응용sw를 연결하는 역할</strong>
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/275177aa-c6a8-4d14-a783-d7d5db19796e/image.png" />
ㅁ운영체제</p>
<p>: 컴퓨터 시스템의 자원을 효율적으로 사용할 수 있게 관리하는 소프트웨어</p>
<p>목적은 사용자에게 편리한 컴퓨팅 환경을 제공하는 것임</p>
<p>컴퓨터가 작동하는 내내 주기억장치에 상주하며 함께 작동함 / hw에 가장 가까운 위치 </p>
<p>o 기능:</p>
<p>(다중 프로그래밍 시스템이 사용되며 os의 프로세스,메모리 관리 기능이 중요해짐)</p>
<p>-<strong>자원 관리</strong> : cpu 스케줄링, 메모리 관리, 프로세스 관리 _여러 프로세스가 서로 충돌하지 않도록 메모리 상의 프로세스를 관리해야 하고, 메모리 내 프로세스의 위치 추적을 위해 메모리 관리도 해야 함 </p>
<p>-<strong>자원 보호</strong> : 프로그램의 오류, 자원이 잘못 사용되는 것을 감시함</p>
<p>-<strong>사용자 인터페이스 제공</strong> : 사용자가 컴퓨터를 편하게 사용할 수 있는 환경을 제공   </p>
<p>o 구성:</p>
<p>-커널 _<strong>운영체제의 가장 핵심적인 부분</strong> / 사용자가 관여하지 못하는 <strong>시스템 레벨 수준의 제어 작업</strong>을 함 / 메모리 관리, 프로세스 관리, 입출력 장치 관리 …</p>
<p>-사용자 인터페이스 _사용자가 직접 프로그램을 제어하고 사용할 수 있는 환경 / 운영체제가 커널</p>
<p>에 명령을 전달하고 <strong>실행 결과를 사용자와 응용 프로그램에 돌려주는 방식</strong> / CLI, GUI</p>
<p>o  종류: </p>
<p>유닉스 / 리눅스 _오픈 소스임 / 윈도우 / 맥 os     컴</p>
<p>안드로이드 / ios     모바일</p>
<p>+컴퓨터 부팅 과정</p>
<p>컴퓨터가 실행되면 ROM의 <strong>부트프로그램(부트스트랩 로더)</strong>가 포스트 작업을 하고, 문제가 없으면 운영체제를 RAM에 적재함, 그럼 <strong>운영체제의 부팅 과정이 실행됨</strong></p>
<p>o 운영체제의 프로세스 관리</p>
<p>-프로세스: 실행 명령을 받아 보조기억장치에서 <strong>메인메모리에 올라간 프로그램</strong> / 컴에서 실행 중인 프로그램 / 운영체제의 시스템 작업의 기본 단위</p>
<p>다중 프로그래밍을 하기 때문에 프로세스를 관리하기 위해 <strong>상태</strong>가 필요함 </p>
<p>ㄴ프로세스의 상태</p>
<p>-준비 Ready : 생성된 프로세스가 프로세서(cpu) 사용 시간을 할당받기 위해 기다리고 있는 상태 / 자원은 할당됨</p>
<p>-실행 Running : os가 신호를 보내, 프로세서(cpu)에 의해 프로세스가 실행되고 있는 상태</p>
<pre><code>(다음 단계로 넘어가는 3가지 루트)

종료 : 프로세스의 모든 작업이 끝나면 종료됨, 종료되면 시스템에서 제거되고, 해당 프로세스가 가졌던 자원은 os에게 반환됨 

중단/방해 : 프로세스의 cpu 할당 시간이 완료되거나, 인터럽트가 발생하면 준비 상태로 감

입출력 | 이벤트 기다림: 실행중인 프로세스가 입출력 명령을 마치면 cpu사용을 반납하고 입출력 종료 신호가 올 때까지 대기 상태로 넘어감 (I/O 작업동안 CPU는 다른 프로세스 실행해 효율 up)</code></pre><p><img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/9e525109-b4bc-4525-b12b-e8c02b8b6663/image.png" /></p>
<p>-대기 Blocked : 입출력 같은 임의의 자원을 요청한 후 할당받을 때까지 기다리는 상태(I/O 작업 등을 처리중), 자원을 할당 받으면 준비 상태로 감
-<strong>프로세스 제어 블록 PCB</strong> : <strong>운영체제가 관리하는 자료구조</strong> / 프로세스 관리에 필요한 정보들이 저장돼 있는 장소 / 운영체제의 커널 안에 있음</p>
<p>프로세스 ID, 레지스터의 백업 값 등이 저장돼 있음</p>
<p>프로세스 마다 별도의 PCB를 가지며 프로세스가 생성될 때 만들어졌다가, 프로세스가 실행을 마치면 사라짐</p>
<p><strong>문맥 전환</strong> : 다중 프로그래밍 환경에서 CPU는 한번에 하나의 프로세스만 처리할 수 있으므로 </p>
<p>실행 중이던 프로세스가 cpu를 다른 프로세스에게 넘겨줘야 할 때 그 프로세스의 정보를 PCB에 넣어서 보관하고, 새롭게 실행 상태가 되는 프로세스의 정보는 cpu에 적재하는 과정 / 중단했던 프로세스(준비 상태)를 다시 실행 시키고자 할 때 PCB에 저장했던 정보를 사용함
: 다중 프로그래밍 환경에서 현재 실행 중인 프로세스 <strong>다음에 어떤 프로세스를 실행하면 좋을지 결정하는 과정</strong> (준비 상태의 프로세스 중에서 선택함)
  <figure>
    <img src="https://velog.velcdn.com/images/kimlj0814/post/22baa5f9-bc6f-44e9-b8da-25ac8a7fff05/image.png" /><br />    <figcaption>문맥 전환이 일어날때 마다 cpu와 pcb의 레지스터 값이 서로 교환됨</figcaption>
  </figure>
-프로세스 스케줄링</p>
<p>: 다중 프로그래밍 환경에서 현재 실행 중인 프로세스 <strong>다음에 어떤 프로세스를 실행하면 좋을지 결정하는 과정</strong> (준비 상태의 프로세스 중에서 선택함)</p>
<p>cpu사용 시간을 할당</p>
<p>(기법 3가지)</p>
<pre><code>선도착 선처리 기법 : 먼저 준비 상태로 들어온 프로세스를 먼저 실행시킴 / 가장 간단

최단작업 우선 기법 :  **cpu 사용 시간이 가장 짧은 것**부터 실행시키는 방법 / 프로세스의 총 실행시간을 미리 알아야 함

순환 순서 기법 : 여러 프로세스가 돌아가며 CPU를 조금씩 차지하는 방법 / 준비 상태에 있는 프로세스에게 cpu 실행 시간을 골구루 나눠줌 / 개인용컴에 적합(**사용자 인터랙션 빈번함**)</code></pre><p>-병행 프로세스</p>
<p>: <strong>2개 이상의 프로세스가 동시에 실행되는 것</strong>, 다른 프로세스와 협력하며 실행돼 서로 영향을 주고 받아, 예측할 수 없는 상황이 발생하기도 함 </p>
<p>// 병행 프로세스는 다른 작업이라도 영향을 주고받는 프로세스가 동시에 처리하는 거고</p>
<pre><code>병렬 프로세스는 같은 작업을 여러 프로세스가 나눠 처리하는 것임</code></pre><p>(<strong>오류를 막기 위해 사용하는 개념)</strong></p>
<pre><code> 동기화 : 하나의 자원(데이터)에 2개 이상의 프로세스가 동시에 접근했을 때 **처리 순서**를 잘 정해 **일관성을 유지**해야 함

 상호 배제 : 하나의 프로세스가 공유 자원을 사용하는 동안 다른 프로세스가 자원을 사용하지 못하게 막는 것  

 임계 영역 : 병행 프로세스의 코드 영역 중 자원을 읽고 수정하는 등의 작업이 이뤄지는 부분 / 하나의 프로세스가 임계 영역에 있으면 다른 프로세스는 접근하면 안됨  _**상호 배제 조건하에** 수행돼야하는 프로그램 영역</code></pre><p>-교착상태: <strong>2개 이상의 프로세스가</strong> 절대 일어나질 않을 이벤트를 기다리고 있는 상태 </p>
<p>빠지는 조건(모두 만족해야 교착상태에 빠짐)</p>
<pre><code>상호 배제: 오직 하나의 프로세스만 공유 자원을 독점해 사용할 수 있음

비선점: 한 프로세스가 작업을 끝내기 전까진 다른 프로세스가 해당 자원을 **뺏을 수 없음**

보유와 대기: 자원을 할당받은 상태에서 다른 자원을 기다림

순환 대기: 각 프로세스가 자원을 갖고 있는 상태에서 다른 프로세스의 자원을 요청함 ⇒ 자원 할당 그래프 만듦 </code></pre><p>교착 상태를 <strong>해결하기 위한 운영체제의 방안</strong></p>
<pre><code>방지: 교착 상태가 발생할 수 있는 조건 4가지 중 하나 이상을 제거해, 애초에 교착 상태가 발생하지 않도록 함 / 엄격한 자원할당이 필요해 오히려 비효율적임

회피: 교착 상태가 발생할 가능성 유무를 검사하고, 발생할 가능성이 없을 경우에만 자원을 할당해 발생을 회피함

탐지와 회복: 교착 상태가 발생했을 때 이를 감지하고 상황을 해결 / 하지만 교착상태를 해결하는덴 많은 비용이 듦

무시: 교착 상태의 발생 여부를 무시함 </code></pre><p>자원 할당 그래프 _상호 배제, 비선점, 보유와 대기, 순환 대기 모두 만족함</p>
<p>프로세스 P1, P2는 자원 R1,R2를 모두 할당받아야만 작업을 완료할 수 있지만, 두 프로세스 모두 자원을 하나만 할당받고 나머지 하나를 기다리는 상태. 즉 영원히 작업을 완료할 수 없는 교착 상태에 빠진 것
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/08b69679-8f9c-4d2f-a987-4cceef6d9164/image.png" />
+멀티 쓰레드 프로그래밍 에서도 병행 프로세스의 개념을 적용 가능</p>
<ul>
<li>응용 소프트웨어</li>
</ul>
<p>: 특정 분야에서 사용하기 위한  sw</p>
<ul>
<li>소프트웨어 공학</li>
</ul>
<p>: sw 개발의 전 과정(계획,운용,유지,폐기)에 필요한 이론과 기술을 다루는 학문 / sw의 크기가 커지며 이를 효과적으로 관리하기 위해 sw 개발과 관련된 일을 체계화한 것임 </p>
<p>ㅁ소프트웨어 개발 주기</p>
<p>: <strong>소프트웨어 개발 과정</strong>을 단계별로 나눈 것 </p>
<p>요구 분석 → 설계 → 구현 → 테스트 → 유지 보수 //개발 방법에 따라 순서 차이가 생김 </p>
<p>ㅁ소프트웨어 개발 방법론</p>
<p>o 폭포수 모델 : 순차적으로 개발 단계를 진행 / 요구 분석이나 설계가 잘못되면 나중에 엄청난 비용, 시간이 소모됨</p>
<p>o 점진적 모델 : 간단한 시스템 먼저 개발 후 나머지 부분을 개발해나가는 방법 //크고 복작한 sw 개발시</p>
<p>o 프로토타입 모델 : <strong>사용자의 요구를 정확히 파악하기 위해</strong> 요구 분석 단계에서 <strong>프로토타입</strong>을 만들어 <strong>최종 결과물을 예측</strong>하는 방법</p>
<p>o 애자일 개발방법론 : 아무 계획 없이 진행되는 개발 방법과, 계획이 지나치게 많은 개발 방법 사이에서 타협점을 찾기 위해 만들어진 방법론</p>
<h3 id="데이터-표현">데이터 표현</h3>
<ul>
<li>수의 체계</li>
</ul>
<p>ㅁ진법: 유한한 심볼로 무한한 숫자를 표현하는 방법    ex) 2진법: 0,1로 무한한 숫자를 표현</p>
<p><strong>사용할 수 있는 숫자의 개수</strong>와, <strong>위치 값</strong>을 정의한 수 체계</p>
<p>ㄴ사용할 수 있는 숫자는 n진법이면 0 ~ n-1 
ㄴn진법으로 표현한 수를 n진수라고 함</p>
<p>+아날로그데이터는 연속적 데이터, 디지털데이터는 비연속적인 데이터임 / 아날로그 데이터를 디지털 데이터로 바꾸려면 2진법을 알아야 함 </p>
<p>10진법: 0~9까지의 10개의 숫자를 한 묶음으로 해 10이 될 때마다 1자리씩 자리올림을 하는 방법 / 10의 지수 승으로 자릿수를 올림
2진법: 0과1로만 수를 표현하는 방법, 컴퓨터가 사용_최초의 컴퓨터가 진공관을 사용했기 때문 / 2의 지수승으로 자릿수를 올림
16진법: 사람 입장에선 2진법이 얼마인지 한 번에 파악하기 어렵고, 자릿수가 길어져 16진법을 사용하기도 함</p>
<p>0.1.2.3.4.5.6.7.8.9.A,B,C,D,E,F</p>
<p>(컴퓨터 용량의 기준 단위)</p>
<p>bit: 컴에서 데이터를 표현하는 최소 단위 / 2진수를 표현하는 가장 기본 단위
ㄴn 비트로는 2^n 개의 숫자 표현 가능</p>
<p>Byte: 문자를 표현하는 단위, 1바이트는 8비트
Word: 컴퓨터가 한번에 처리할 수 있는 데이터의 단위 
ㄴ32bit 컴에서 1워드는 4바이트 /  32bit cpu의 데이터의 기본 단위는 32bit
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/89b7e554-fe65-403b-ade1-8dc65636d09b/image.png" /></p>
<ul>
<li>진법 변환
: 수를 다른 진법으로 변환하는 것
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/69ff75d7-5dc9-4fad-a0da-9b39aa1fedb6/image.png" /></li>
<li>데이터 표현
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/04222f43-1ee4-45ef-98ef-ad0966a4f94b/image.png" />
ㅁ 정수
: 셀 수 있는 수 </li>
</ul>
<p>o 부호가 없는 정수(unsigned) :</p>
<p>0, 자연수</p>
<p>n비트를 이용해 0 ~ 2^n  -1 표현 가능 _<a href="mailto:seim7560@naver.com">2^n가지</a></p>
<p>o 부호가 있는 정수 :  </p>
<p>음수, 0, 양수</p>
<p><strong>표현 방법:</strong></p>
<p>(부호화 절댓값 표현)
: MSB(최대유효비트, 가장 왼쪽 비트)가 0이면 양의 정수(+0 포함), 1이면 음의 정수(-0 포함) 로 표현 </p>
<p>n비트로 부호화 절댓값을 표현할 땐 <strong>절댓값 계산을 위해 n-1 비트까지만 사용 가능</strong>  </p>
<p>-(2^(n-1)-1) ~ 2^(n-1)-1 </p>
<p>→ 0이 2개고, 연산속도가 느려서 컴에선 안 씀</p>
<p>(보수 표현)
<strong>부호라는 개념을 고려하지 않는 방식임</strong>
보수: 각 자리 두 수의 합이 진법의 밑수(n)가 되게 하는 수 _n의 보수
ㄴ 밑수 == n진법에서 수의 표현에 사용되는 숫자의 개수 == n</p>
<p>e.g. 8.5(10)의 9의 보수는 1.4(10)</p>
<p>10의 보수는 주어진 수의 가장 큰 자리수에서 올림한 수에서 주어진 수를 빼서 구함 ex) 529(10)의 10의 보수는 1000-529=471(10) / 9의 보수는 각 자리 수의 합이 9가 되는 수를 구함</p>
<p>2의 보수는 LSB부터 처음으로 1이 나올 때까진 놔두고 그 왼쪽은 다 1의 보수로 바꿈</p>
<p>n비트로 보수를 표현할 땐 <strong>n-1 비트까지만 사용 가능</strong>  </p>
<p>-2^(n-1) ~ 2^(n-1)-1</p>
<p>+2의 보수의 규칙성: MSB가 1이면 음수, 0이면 양수 / 0(0000 0000)으로 인해 2의 보수는 음수가 양수보다 1개 더 많다 / MSB를 제외한 비트가 큰 숫자들이 실제로도 큰 숫자이다 e.g. 1111 1111(2)=-1(10) <strong>&gt;</strong> 1111 1110(2)= -2(10)</p>
<ul>
<li>-13(10)=110011(2) _6bit    진법 변환이랑, 비트 맞추는거 먼저 하고, 보수 표현은 마지막에 하셈!!!</li>
</ul>
<p>(부호가 있는 정수, 없는 정수 모두)
2진법을 이용한 사칙연산 방법은 10진법에서의 연산 방법과 동일함
LSB(최소유효비트,가장 오른쪽 비트)부터 각 비트의 수를 더하고, 1+1의 자리올림이 발생하면 상위 자리로 1을 올림
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/8b9dae8b-a1be-4f63-9099-6e66e2466bc3/image.png" />
o 컴퓨터는 양수, 음수를 구분하지 않음 그냥 그 자체로 컴퓨터가 이해할 수 있는 숫자임 / 사람이 읽기 위해 양수, 음수를  구분하는 것임 </p>
<p>ㅁ 실수</p>
<p>: 유리수, 무리수를 포함하는 확장한 수, 수직선 위에 나타낼 수 있는 모든 수 </p>
<p>(컴퓨터 내부에서 실수를 표현하는 방법)</p>
<p>ㅇ고정소수점 표현</p>
<p>: 소수점의 위치를 고정해 표현함</p>
<p>비트 수에 맞춰 정수 부분과 소수 부분으로 나눠 저장 _정수부는 오른쪽 채운 후 왼쪽 남은 건 0으로 채움, 소수부분은 왼쪽부터 채움
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/750162e8-87ba-4a38-9e46-064461e6e62c/image.png" />
숫자 표현이 간단해 연산 속도가 빠르지만 컴에선 이 방식 사용 X</p>
<p>고정소수점 표현 방식에선 오버플로우 발생 가능 : 정수부가 나타낼 수 있는 상한보다 큰 수 저장해 정밀도 상실 </p>
<p>ㅇ부동소수점 표현</p>
<p>: 소수점의 위치 고정 X / 가수, 지수를 사용해 실수를 표현 / 부호부, 가수부, 지수부로 나눠 이진 표현으로 저장 / 한정된 저장공간에 많은 정보를 넣을 수 있음</p>
<p>가수==유효숫자(정밀도) / 지수==소수점의 위치(범위)를 나타냄</p>
<ol>
<li>정규화 : 먼저 정수 부분에 0이 아닌 수를 하나만 남기는 정규형(nomalized form)으로 표현해야함 _실수의 소수점을 이동(소수점의 원래 위치는 지수로 표현)</li>
</ol>
<p><a href="http://1.xxx">1.xxx</a> * 2^n (부동소수=정규화된 실수 표현) </p>
<p>//0.34(10)을 2진수로 바꾸면 0.010101110(2) → 정규화 하면 1.0101110*2^-2(부동소수)</p>
<p>→(컴퓨터에 저장될 땐)
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/23c3fda5-eead-4753-8ee1-cdbeda4f39c4/image.png" />
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/d86944d9-90b1-46c5-a64a-a2244e0c7ea1/image.png" />
그런데 이를 다시 10진수로 바꾸면 원래 값과 차이가 있음</p>
<p>컴퓨터가 표현할 수 있는 수와 실제 수의 차이가 생긴 것임 == 컴퓨터에서 표현 가능한 숫자는 크기가 제한돼 있고, 제한된 정밀도를 가지기 때문임</p>
<p>o 부호부 Sign : 실수가 양수면 0, 음수면 1 </p>
<div style="width: 55%; height: 500px; float: left;">
o 지수부 Exponent: 

<p>지수를 이진 표현으로 저장할 땐</p>
<p> 2^(n-1) -1 초과 표현 사용 (n은 지수 저장에 사용하는 비트 수) : 지수에  2^(n-1)-1 을 더해 저장 </p>
<p>// 지수에 초과 표현을 사용하면 비트가 증가하는 방향이 정수와 동일해짐, 실수끼리 크기 비교에 유리 (가수를 볼 필요 없이 지수가 크면 더 큰 수임, 지수값이 같으면 가수 비교 필요)</p>
<p>실수의 연산보다 정수의 연산이 더 빠르기 때문에 이는 큰 장점임</p>
</div>
<div style="width: 45%; height: 500px; float: right;">
    <img src="https://velog.velcdn.com/images/kimlj0814/post/3cdb4ee4-b0d4-47d0-983a-9842850d8700/image.png" />  
</div>
o 가수부 Significand

<p>부동소수의 가수를 왼쪽부터 저장, 남은 오른쪽 비트는 모두 0으로 채움</p>
<p>+<strong>0은 정규화된 표현으로 나타낼 수 없음</strong> </p>
<p>1 000 0000(2) = -0.0(10)
0 000 0000(2) = +0.0(10)</p>
<p>→ 0이 두개이기 때문</p>
<p>가장 작은 양수 0 000 0001 / 가장 큰 양수 0 111 1111
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/f389697c-3b5b-49bc-ad10-907214d4e5b1/image.png" /></p>
<p>부동소수점 표현에선 오버플로우와, 언더플로우 모두 발생 가능 :</p>
<p>양수값을 갖는 <strong>지수</strong>가 지수부 상한보다 크면 오버플로우 / 음수값을 갖는 지수가 지수부 하한보다 작으면 언더플로우 발생</p>
<p>→ 이걸 줄이기 위해 float 대신 지수부분이 더 큰 double 표현형식을 사용할 수 있음 </p>
<p>hidden bit : 2진수는 가수부 첫 비트가 무조건 1이니까(정규화) 생략하고 다른 비트 하나 더 저장하자 → 정확도 높아짐, <strong>하지만 0을 표현하지 못함</strong> → 0과 1은 special values로 zero와 infinite로 표현
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/8041b2a1-cbd2-4b4e-bda1-45ad63e34edb/image.png" />
ㅁ 문자</p>
<p>아스키코드 : 7비트, 2^7(128)개 문자 표현 가능, 컴으로 문자를 처리하기 위해 숫자와 문자를  대응시킴
유니코드 : 더 많은 수의 비트로 다양한 나라의 언어를 표현하고자 만든 코드, 언어의 종류에 상관 없이 모든 문자를 큰 비트로 표현 </p>
<h3 id="논리회로">논리회로</h3>
<p>: 논리 연산을 수행하는 회로</p>
<p>‘논리’ 는 참, 거짓을 다룬다는 의미 / 논리 연산은 참, 거짓으로 연산하는 걸 의미</p>
<p>IC(==<strong>논리 게이트</strong>): 반도체 칩으로 구성됨 _실제 회로 구성에 사용됨</p>
<p>ㄴ컴퓨터를 구성하는 가장 작은 단위의 논리회로 / 전기 신호에 따라 가장 기본적인 동작을 수행하는 소자 </p>
<p>ㅁ 논리회로의 동작, 기능을 기술하는 법</p>
<p>논리식 : 논리 연산자로 구성된 식
논리도 : 논리식을 시각적으로 구현한 그림
논리표(진리표) : 논리회로에 입력 가능한 모든 경우의 수에 대응하는 출력값을 정의한 표</p>
<p>ㅁ 논리 연산자</p>
<p>논리 연산을 다루려면 필요함</p>
<p><strong>1 | 0 을 피연산자로 사용하는 연산자</strong>
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/b8fed642-4a17-4197-899f-8d42326dae15/image.png" />
(논리 게이트를 이용해 회로를 만드는 방법)</p>
<p>ㅁ 조합논리회로
: 입력 값만으로 출력값이 결정되는 회로 </p>
<p>-1비트 반가산기 (Half adder) : </p>
<p>가장 단순한 형태의 가산기
XOR 게이트 1개 , AND 게이트 1개로 만들어짐
자리올림을 처리하지 못함 _<strong>2비트끼리 덧셈을 나타낼 수 없음</strong>
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/6a39b91c-645c-4746-94f8-dab4d1c40ce9/image.png" />
-1비트 전가산기 (Full adder):</p>
<p>반가산기 2개를 이용해 만듦
하위 비트에서 생긴 <strong>자리올림을 고려해 만들어짐</strong>
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/4befc83f-09fa-44bd-9bfd-ed16261631df/image.png" />
-멀티비트 전가산기(여러개의 전가산기 이용)
4비트 리플캐리 가산기: 1비트 전가산기 4개를 연속으로 배치함
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/b64974f5-5f6b-489e-a60f-036858292e9b/image.png" />
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/6b83a405-57d5-4222-82c5-e8c77a696406/image.png" />
ㅁ 순서논리회로
: 입력값과, <strong>회로 내부 상태</strong>가 출력값을 결정하는 회로</p>
<p>조합논리회로와 차이는 회로 내부 상태를 저장하는지 여부
ㄴ순서 논리회로는 <strong>상태를 저장하므로 메모리가 필요</strong> → 회로 중 레지스터, 메모리 등 기억장치가 들어있는 부품은 순서 논리 회로로 구성돼 있음</p>
<p>플립플롭 : 컴에서 1비트의 정보를 저장하는 회로
2가지 상태( 0 | 1) 를 저장할 수 있고, 입력 신호가 변하기 전까지 현재 상태를 그대로 유지함 → 메모리 기능 가능 / 램, 레지스터 (기억장치) 구현에 사용됨 
-저장원리: 회로의 안정 상태
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/83da4ea9-312a-4a5f-8eb9-45554c8ea874/image.png" /></p>
<h3 id="프로그래밍-언어">프로그래밍 언어</h3>
<p>프로그래밍은 컴이 이해할 수 있는 실행 프로그램을 만드는 것이고 그 때 사용하는게 프로그래밍 언어임 </p>
<p>(<strong>hw지향, 컴 내부</strong> 표현에 가까운 정도로 나눔)</p>
<ul>
<li><p>저급언어
ㅁ 기계어 : 2진수 형태의 0,1로 작성 / 컴이 직접 이해 가능
ㅁ 어셈블리어 : 기계어를 기호화한 언어 / CPU 종류에 영향을 받음 </p>
</li>
<li><p>고급언어</p>
</li>
</ul>
<p>: 사람이 이해하기 쉬움 / 저급 언어보다 이식성이 높음 / 컴파일러|인터프리터에 의해 저급 언어로 번역돼 실행됨</p>
<ul>
<li>프로그래밍 언어의 실행 과정</li>
</ul>
<ol>
<li>고급언어로 소스코드를 작성해 소스 파일을 만듦 _소스파일은 어떤 텍스트 에디터를 사용하든 텍스트 파일로 저장하기만 하면 됨</li>
</ol>
<p><strong>통합개발환경</strong> (IDE) : 텍스트 에디터, 컴파일러, 링커, 로더 디버거 등을 통합적으로 제공하는 개발 환경 __비주얼베이직</p>
<ol start="2">
<li>프로그래밍 언어의 번역</li>
</ol>
<p>고급 프로그래밍 언어로 작성된 소스코드를 <strong>컴이 이해하려면</strong> 기계어로 번역해야 함 </p>
<p>(프로그램 구현 방식에 따라 2가지로 나눔)
o <strong>컴파일러</strong> : 프로그램 전체 소스코드를 기계어로 한번에 번역해 실행 파일을 만든 뒤 프로그램을 실행하는 방식
컴파일 : 소스 전체를 개체 파일(기계어)로 번역하는 과정
<strong>소스코드에서 미리 오류를 찾아 실행했을 때 문제가 생길 일이 없음</strong>→최적화된 작업 가능, 실행 속도가 빠름</p>
<p>__C, JAVA</p>
<p>o <strong>인터프리터</strong>  :  소스코드를 한 행씩 읽으며 번역과 실행을 동시에 수행하는 방식 
컴파일러를 이용한 방식보다 속도가 느리지만 ( 컴파일러는 한 번에 번역해두고 실행하지만, 인터프리터는 프로그램 소스코드 번역과 실행을 동시에 하므로), 즉각적인 피드백 가능</p>
<p>__파이썬 </p>
<ol start="3">
<li>개체 파일(목적파일)은 프로그램을 실행하는 os가 인식할 수 있는 형태로 바꿔야 해 링커를 통해 링킹 과정을 거침 → 실행 파일 만들어짐</li>
<li>작성된 프로그램은 컴퓨터 메인메모리에 로드되는 <strong>로더 과정</strong>을 거침</li>
<li>모든 과정이 마무리되면 프로그램이 실행됨
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/341440fd-5968-4a7e-8db2-1849b2205467/image.png" /></li>
</ol>
<ul>
<li>프로그래밍 언어의 분류 (고급언어)
(프로그래밍 방식을 기준으로 나눔)</li>
</ul>
<p>ㅁ 절차 지향 언어
실행 순서를 중심으로 설계하는 프로그래밍 언어
명령어를 절차(순차)적으로 표현
데이터(변수)와 기능(함수)을 별도로 관리해 <strong>기능을 호출</strong>한 뒤 <strong>데이터에 접근</strong>해 일을 처리</p>
<p>__C  C++(절차지향+객체지향) 포트란 베이직 코볼</p>
<p>ㅁ 객체 지향 언어
프로그램을 독립된 단위인 ‘객체’들의 집합으로 보는 언어
데이터와 기능을 하나로 묶어 <strong>캡슐화</strong>한 후 <strong>메세지를 전달</strong>해 일을 처리하므로 효율적임</p>
<p>__JAVA  Python  C++  </p>
<p>+논리형 언어 (GUI에는 맞지 않음)
<strong>논리학의 관계식 형태</strong>로 프로그램을 기술한 언어 
논리식을 바탕으로 객체 간의 관계(프로그램의 로직이 표현되는 방법)에 대한 문제를 해결할 때 주로 사용
관계에 바탕을 둔 쿼리를 수행해 계산
인공지능, 계산 언어학 분야에서 사용</p>
<p>__프롤로그(PROLOG)</p>
<p>+함수형 언어
데이터에 대한 함수 적용을 바탕으로 처리 과정을 기술한 언어
모든 연산이 함수 평가에 따라 표현되는 언어
변수, 할당문, 대입 연산자, 제어문을 쓰지 않음, 상태 변환이 많은 기기에는 쓰기 안좋음 </p>
<p>__리스프(LISP)  스킴(Scheme)</p>
<ul>
<li>프로그래밍 문법</li>
</ul>
<p>ㅁ 변수
: 어떤 값을 저장하는 메모리 공간</p>
<p>자료형: 프로그램에서 사용되는 자료의 구조를 정의한 것 / 파이썬은 객체지향언어라 클래스를 만들어 변수를 사용할 수 있어 사용 가능한 자료형은 무한대임 / 실수형(float), 정수형(int), 문자형(str) …</p>
<p>일반적으로 프로그래밍을 시작할 땐 변수의 자료형을 선언해야 함 
ㄴ파이썬은 변수를 따로 선언하지 않아도 되는 ‘동적 타이핑’ 임 / 변수 초기화와 동시에 메인메모리에 적재됨
ㄴ 동적 타이핑 언어는 코드 작성 시간이 짧아 생산성이 높지만, 유지보수를 해야 할 땐 정적 타이핑 언어보다 가독성이 떨어진다는 단점이 있음</p>
<p>파이썬 문법</p>
<pre><code class="language-python">a=input() #으로 받는 건 문자형으로 됨
#다른 형식으로 바꾸려면 
a=int(input())

print(2/4) #나누기 , 실수형
print(2//4) #몫만 

#논리 연산자
'''and or not'''
print(a and b) # true | false 로 출력됨

#비교 연산자
'''==  !=  &gt;  &lt;  &gt;=  &lt;='''

#제어문
 #조건문 : 조건에 따라 특정 동작을 하게 하는 프로그래밍 명령어 
 #if 문
if a==b: 
    print(a)
elif a&gt;b:
    print(b)
else:
    print(a//b)

 #반복문 : 특정 코드가 반복적으로 수행되게 하는 명령어
  #for문
for 변수 in range(start, end+1, up):
    명령문
'''
시작값, 증가값 생략 (0~ 1++)
증가값 생략 (1++)
가능
list로 줄 수 있음 (변수는 리스트 요소가 됨)
'''
  #while문
while 조건문:
    명령문
'''조건문을 만족하는 동안 명령문 수행'''

#반복문 제어 
#break문
#반복문 종료해버림
for i in range(1,11):
    if i==8:
            break
    print(i)     #1~7까지 출력
#continue문
#뒤는 무시하고 다음 반복문 수행
for i in range(1,11):
    if i==7:
            continue   
    print(i)     #7빼고 출력</code></pre>
<h3 id="자료구조">자료구조</h3>
<p>: 자료의 <strong>구조적 특징</strong>이 잘 나타나도록 <strong>체계적으로 데이터를 저장하고, 사용하는 방법</strong>
자료구조와 알고리즘은 서로에게 중요한 개념임</p>
<p>ㄴ알고리즘 : 적합한 순서대로 수행하기만 하면 제한된 시간에 주어진 문제를 해결할 수 있는 <strong>명령어들의 집합</strong> 
ㄴ 프로그램(알고리즘)을 작성할 때 필요한 데이터를 효율적으로 배치한 <strong>자료구조</strong> 필요</p>
<ul>
<li>구조</li>
</ul>
<p><strong>단순 구조</strong> : 개별 자료의 자료형 _정수, 실수, 문자, 문자열
<strong>선형 구조</strong> : 어떤 <strong>순서에 따라</strong> 데이터들이 한 줄로 늘어선 자료구조 </p>
<p>ㅁ 배열
: <strong>자료형이 같은</strong> 자료를 메모리에 <strong>연속으로 저장</strong>해 만듦
인덱스 : 배열 요소를 구별할 때 사용하는 번호, 0부터 시작</p>
<pre><code class="language-python">name=[1,2,3]
print(name[1]) //각 배열 요소는 배열 이름[인덱스] 형태로 변수처럼 사용

#2차원 배열
#인덱스 2개를 이용
name=[[1,2][3,4]]  

#요소 추가, 요소 삭제 하면 다른 요소의 인덱스도 움직임
#==논리적 순서와 물리적 순서가 일치해 둘 다 움직이게 됨 

# -&gt; 이 점을 보완하고자 '연결리스트' 사용</code></pre>
<p><img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/afa9752a-4eca-4cd3-aefd-8edf2f7a9257/image.png" />
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/bb2080bb-75af-45bc-bfb8-a79395842505/image.png" />
ㅁ 연결리스트 : 각 데이터에 저장된 <strong>다음 데이터의 주소</strong>에 따라 <strong>순서가 연결되는 방식</strong> / 배열의 문제를 개선한 표현 방법<em>데이터들의 논리적인 순서,물리적인 순서가 **일치하지 않아도 됨</em>**배열처럼 물리적 주소로 순서를 표현하는 게 아니고 링크에 따라 순서가 연결됨</p>
<p>-구조</p>
<p>  노드: 연결리스트를 구성하는 단위, &lt;원소,주소&gt; 형태</p>
<p>  노드의 구조: 데이터 필드, 링크 필드_<strong>다른 노드의 주소값을 저장</strong>하는 포인터</p>
<p>-종류</p>
<p>  단순 연결 리스트 : 노드의 링크 필드가 다음 노드와 연결되는 가장 기본 구조 </p>
<p>  원형 연결 리스트 : 단순 연결 리스트의 마지막 노드가 리스트의 첫번째 노드를 가리키게 하여 <strong>원형으로 만든 구조</strong></p>
<p>  이중 연결 리스트 : 노드가 양쪽으로 연결돼 양쪽으로 모두 순회 가능 / 단순 연결 리스트,원형 연결 리스트의 단점을 보완한 구조
  <figure>
    &lt;img src=&quot;<a href="https://velog.velcdn.com/images/kimlj0814/post/0f8fbf1e-a913-4ed0-8ed8-3771568c99b6/image.png&amp;quot">https://velog.velcdn.com/images/kimlj0814/post/0f8fbf1e-a913-4ed0-8ed8-3771568c99b6/image.png&quot;</a> height=&quot;30%&quot;</p>
<blockquote>
  </figure>
ㅁ 스택
: 데이터를 쌓아 올린 형태의 자료구조
맨 위에서만(TOP) 데이터의 추가, 삭제 가능 / 후입선출(LIFO)
</blockquote>
<p>활용: undo 기능</p>
<p>스택에서 데이터 추가 및 삭제 : push(append), pop _파이썬에서</p>
<pre><code class="language-python">a=[1,2,3]       //리스트 만듦
a.append(4)     //리스트 맨 끝에 요소 추가
a       '''[1,2,3,4]'''
a.pop() '''4''' //리스트 맨 끝 요소 삭제, 삭제되는 값 반환도 해줌</code></pre>
<p>ㅁ 큐
: 데이터가 한 방향으로만 삽입되고, 반대 방향으로만 삭제되는 자료구조 _스택의 반대 개념
한쪽 끝을 Front라 정해 삭제 연산만 수행하고, 다른쪽 끝을 Rear라고 해 삽입 연산만 수행 / 선입선출(FIFO)</p>
<p>활용: 대기줄(버퍼링)</p>
<p>큐에서 데이터 추가 및 삭제 : push(append), pop</p>
<pre><code class="language-python">a=[1,2,3]       //리스트 만듦
a.append(4)     //리스트 맨 끝에 요소 추가
a       '''[1,2,3,4]'''
a.pop() '''4''' //리스트 맨 끝 요소 삭제, 삭제되는 값 반환도 해줌</code></pre>
<p><strong>비선형 구조</strong> : <strong>*<em>데이터 간의 *</em>상관 관계를 연결상태로 표현</strong>하는 구조 / 비순차적 성질을 가짐</p>
<p>ㅁ 트리
: 데이터들이 1 : n 관계인 비선형 구조</p>
<p>-구성:
   노드: 트리의 원 _Data
   간선: 노드와 노드를 연결한 선 _Link</p>
<p>-계층 구조임: 트리는 <strong>계층 관계</strong>를 가지며, 노드를 이용해 부모-자식 간 관계를 표현함
  루트 노드: 트리의 맨 위에 위치한 노드, 레벨0 
  단말 노드: 트리의 가장 아래에 위치한 노드들 _꼭 같은 레벨은 아님
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/9bc2b1ab-c52e-4441-9dcd-78d18d20e1cc/image.png" />
-종류:</p>
<p>  이진 트리: 노드의 <strong>자식 노드를 2개 이하</strong>로 정해 놓은 구조
  +서브트리
  <img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/f6ac49e1-db4f-48f5-9041-6fc6aaaac1bd/image.png" />
ㅁ 그래프
: 연결된 데이터들의 <strong>n : n 관계</strong>를 표현하는 자료구조</p>
<p>그래프에는 <strong>사이클 존재</strong> _트리와 차이점 
그래프(G)는 G=(V,E)로 정의
ㄴV는 정점의 집합, E는 간선의 집합을 의미</p>
<p>-구성: <strong>정점</strong>(연결할 객체)과, <strong>간선</strong>(객체를 연결함)의 집합 </p>
<p>-종류:
  무방향 그래프: 두 정점을 연결하는 <strong>간선의 방향이 정해져 있지 않은</strong> 그래프
  방향 그래프: <strong>간선의 방향이 정해져 있는</strong> 그래프</p>
<p>+방향 그래프는 2차원 배열로 표현할 수도 있음
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/38e80bd2-7b5f-427a-bed2-a80dbb7222a9/image.png" /></p>
<p>활용: 지하철 노선, 네비게이션 알고리즘 </p>
<h3 id="알고리즘">알고리즘</h3>
<p> : 문제를 해결하기 위한 일련의 절차 </p>
<ul>
<li>표현 방법: <strong>자연어_</strong>쉽게 작성 가능, but 명확하지 않은 표현 <strong>*<em>/ *</em>순서도_</strong>기호,선을 이용해 처리과정 표현, 전체적인 구조 흐름을 파악하기엔 유리 but 복잡한 알고리즘을 표현하기엔 좋지 않음 <strong>*<em>/ *</em>의사코드</strong>_구조는 프로그래밍 언어와 비슷하지만 특정 플밍 언어의 문법을 따르진 않음 / <strong>프로그래밍 언어</strong></li>
<li>조건 : <strong>입력</strong>_0개 이상 <strong>/</strong> <strong>출력</strong>_1개 이상 <strong>/</strong> <strong>유한성</strong>_알고리즘은 반드시 종료돼야 함 / <strong>명확성</strong>_명령은 명확해야 함 / <strong>실행 가능성</strong>_명령은 실행 가능해야 함</li>
<li>알고리즘의 설계: 가장 <strong>효율적인 문제 해결 방법</strong>을 찾아내는 과정</li>
</ul>
<p>알고리즘 <strong>제어 구조의 종류</strong>_명령 실행 순서 정함 :</p>
<p>  순차 구조
  선택 구조_조건의 결과에 따라 명령을 선택해 수행하게 함
  반복 구조 </p>
<ul>
<li>성능 분석 (복잡도 분석)</li>
</ul>
<p><strong>알고리즘의 복잡도</strong>는 특정 기준에 따라 알고리즘의 수행 속도를 나타낸 것임
<strong>알고리즘 효율성을 분석</strong>하는 데 중요한 기준은 CPU 실행 시간임,
그래서 알고리즘의 명령어가 실행되는 횟수로 알고리즘 수행에 필요한 시간을 분석하는 <strong>시간 복잡도</strong>를 이용해 알고리즘의 복잡도를 분석함
<strong>빅오표기법</strong>은 입력개수에 따라 알고리즘의 연산 횟수가 얼마나 증가하는지 나타낸 것으로, 시간복잡도를 근사적으로 표현하는 방법임</p>
<p>ㅁ빅오 표기법 : 
최고차항만, 계수도 버리고 표시하는 이유는 <strong>효율성 분석에서 중요하지 않기 때문</strong></p>
<p>O(n^2)이면 <strong>알고리즘의 처리 횟수가 n^2만큼 증가한다는 것임</strong></p>
<p>시간 복잡도 비교 : <strong>O(1)</strong>_입력 개수와 무관하게 일정 시간이 걸리는 경우 &lt; <strong>O(logn)</strong>_데이터 양을 매번 절반으로 분할해 처리하는 알고리즘, 이진검색&lt; <strong>O(n</strong>)_알고리즘의 작업량이 입력 개수에 비례하는 경우 &lt; <strong>O(nlogn)</strong>_고급 정렬 알고리즘, 병합 정렬 &lt; <strong>O(n^2)</strong>_선택정렬, 단순한 정렬 알고리즘</p>
<ul>
<li>정렬 알고리즘 :</li>
</ul>
<p>정렬: 데이터를 규칙에 따라 <strong>재배열</strong> 하는 것 </p>
<p>-종류:</p>
<p>  ㅁ선택 정렬 : 정렬돼 있지 않은 데이터 중 최솟값을 정렬돼 있지 않은 부분에서 맨 앞 데이터 위치와 바꾸는 알고리즘    ==오름차순으로 정렬 / 시간 복잡도는O(n^2)</p>
<pre><code>진행 과정: 

1. 정렬되지 않은 데이터에서 최솟값을 찾음
2. 그 값과 정렬되지 않은 데이터의 맨 앞 데이터의 위치를 서로 바꿈
3. 위 과정 반복</code></pre><p>(내림차순)
정렬되지 않은 데이터에서 최대값을 찾아 정렬되지 않은 맨 앞 데이터와 서로 위치를 바꿈</p>
<pre><code class="language-python">import random

def selection_sorting(data):
  for i in range(0,len(data)):     # 인덱스 하나씩 옮기며 모든 요소 검사함
        min=data[i]       # 일단 맨 앞 데이터를 최소라고 함
    for j in range(i+1,len(data)): # 정렬되지 않은 데이터 검사
      if min&lt;data[j]: # 그 뒤에 더 작은 수 있으면==최솟값 찾으면
                min=data[j]   # 최소값 바꿔주고
        data[i],data[j]=data[j],data[i] # 맨 앞 데이터와 위치를 바꿈
  return data

a=random.sample(range(100),10)
print(a) #원본 data
b=selection_sorting(a)
print(b) #바뀐 data</code></pre>
<p>ㅁ버블 정렬 : 나란히 놓인 <strong>두 데이터 중</strong> 숫자가 큰 데이터를 뒤로 보내며 정렬하는 방식 ==오름차순 정렬 / 시간 복잡도는 O(n^2)</p>
<pre><code>진행과정: 
1. 왼쪽에 놓인 데이터부터 시작해, 크기순으로 자리를 서로 바꿈
 (그럼 가장 큰 수가 가장 오른쪽으로 감)
2. 이 과정 반복</code></pre><p>(내림차순)
나란히 놓인 데이터에서 더 큰 수를 앞으로 보내며 정렬</p>
<pre><code class="language-python">import random
def bubble_sorting(data): 
  for i in range(len(data)):       # 배열 요소 개수 번 큰수를 끝으로 기는 거 반복
    for j in range(0,len(data)-i-1): # 0~정렬되지 않은 숫자 인덱스-2까지_뒤 요소와 비교할 거여서 리스트 범위 벗어나지 않게!
      if data[j]&gt;data[j+1]:        # 뒤 요소보다 크면
        data[j],data[j+1]=data[j+1],data[j] # 뒤 요소와 자리를 바꿈
  return data

a=random.sample(range(100),10)
print(a) #원본 data
b=bubble_sorting(a)
print(b) #바뀐 data</code></pre>
<p>ㅁ삽입 정렬 : 정렬돼 있지 않은 데이터를, 정렬돼 있는 부분에서 적절한 위치에 삽입하는 정렬 </p>
<p>두번째 데이터부터 앞부분에서(정렬된 부분) 들어갈 적절할 위치를 찾음_자기보다 작은 거는 넘어가고 크면 뒤로 밀고 그 사이에 들어감 (오름차순) / 시간 복잡도는 O(n^2)</p>
<p>(내림차순)
두번째 데이터부터 정렬된 부분에 데이터 하나씩 확인해, 자기보다 큰 거는 넘어가고, 작으면 뒤로 밀고 그 사이에 들어감</p>
<pre><code class="language-python">#삽입정렬
import random
def push_sorting(data):
  for i in range(1,len(data)): # 2번째 인덱스부터 끝까지 반복
      push=data[i] # 삽입할 데이터
      j=i          # 삽입할 데이터의 인덱스
      while j&gt;0 and data[j-1]&gt;push: # 삽입할 인덱스 앞에 있는 요소가 삽입할 데이터 보다 큰 경우까지
          data[j]=data[j-1] # 앞에 있는 걸 뒤로 밈 ==뒤에 인덱스에 앞에 있던 거 넣음
          j-=1 # 인덱스 하나 앞으로 옮겨서 다시 검사
      data[j]=push #삽입할 거 보다 큰 거 다 민 다음에, 빈 자리에 삽입 
      '''잘 정렬돼 있으면 그냥 전체 요소 한 번 훑고 넘어갈 수 있어 _while문 넘어감
                최선의 경우 O(n) / 선택,버블,병합 은 무조건 비교 거쳐야 함'''
  return data

a=random.sample(range(100),10)
print(a) #원본 data
b=push_sorting(a)
print(b) #바뀐 dat</code></pre>
<p>ㅁ병합 정렬 : 정렬된 여러개의 자료 집합을 병합해 <strong>하나의 정렬된 집합</strong>으로 만드는 정렬 방법 / 시간 복잡도는 O(nlogn)</p>
<pre><code>수행 과정 :</code></pre><p><img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/f44aff2c-2d54-4671-89ba-e828b57c77c7/image.png" />
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/bcf88f64-093b-48c1-b876-7b0f6a7ebfb2/image.png" /></p>
<ul>
<li>검색 알고리즘</li>
</ul>
<p>검색 : 특정 데이터 집합에서 어떤 조건, 성질을 만족하는 데이터를 찾는 것</p>
<p>검색 알고리즘 : 검색의 개념을 활용한 알고리즘</p>
<p>  ㅁ순차 검색: <strong>일렬로 나열된 데이터</strong>를 처음부터 끝까지 <strong>순서대로 검색</strong>하는 방법 / 선형 자료구조에서 자주 쓰임</p>
<p>검색해야 하는 자료의 양에 따라 효율이 달라짐 / 검색해야 할 데이터의 정렬 여부에 따라 검색 실패를 판단하는 시점이 달라짐 / O(n)</p>
<p> -정렬돼 있지 않은 데이터의 순차 검색 
마지막 데이터까지 비교해도 일치하는 데이터가 없으면 검색에 실패한 것임 _ <strong>끝까지 다 조사해봐야 검색 실패 여부 판단 가능</strong></p>
<p>-정렬돼 있는 데이터의 순차 검색 
검색하다가 다음 데이터 값이 검색 값보다 크면 찾는 데이터가 없다는 뜻이므로 검색 실패 여부를 바로 파악할 수 있음_오름차순</p>
<p>ㅁ이진 검색 : <strong>정렬된 데이터에서</strong> 중간값과 검색값을 비교하며 검색 대상을 줄여나가며 검색하는 방식</p>
<p>원하는 값을 찾을때까지 <strong>검색 범위를 계속 줄여가며 빠르게 반복 수행</strong>함 / 데이터를 평균 1/3씩 줄여 데이터양이 많을 떄 활용하면 좋음 / O(logn) <strong>매우</strong> <strong>효율적</strong>
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/e7c9653d-21e1-47f5-894e-ab417945846e/image.png" />
ㅁ해싱 : 키값을 해시 함수에 대입해 나온 <strong>해시 주소를 사용해</strong> 바로 값에 접근하는 방법 / <strong>배열의 이점을 활용</strong>하는 검색 알고리즘임 / <strong>O(1)</strong></p>
<p>해시 함수:  키값을 <strong>데이터 위치(해시 주소)</strong>로 변환하는 함수 
해시 테이블: 해시 함수에 따라 <strong>계산된 데이터 위치에 항목을 저장한 표</strong> / 해시 주소가 인덱스 역할을 함
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/bfc5e012-8303-4827-8fdb-b4e90a0cb598/image.png" /></p>
<h3 id="db"><strong>DB</strong></h3>
<p>DB 전</p>
<p>파일 처리 시스템 : <strong>업무별로</strong> 파일을 작성, 처리하는 시스템</p>
<p>문제점-같은 내용의 데이터가 여러 파일에 중복으로 저장됨 / 응용 프로그램에 종속됨 / 데이터 파일에 대한 동시 공유, 보안, 회복 기능 부족, 응용 프로그램 개발이 쉽지 않음  </p>
<p>→ DB로 해결</p>
<p>정보는 현실의 데이터를 유용한 형태로 가공한 것임</p>
<p>정보 처리 : 데이터에서 정보를 추출하는 과정|방법</p>
<p>정보 시스템 : 수집한 데이터를 저장하고 있다가 필요할 때 <strong>유용한 정보로 만들어 주는 수단</strong></p>
<ul>
<li><strong>데이터베이스</strong> : 조직의 여러 사용자가 정확한 의미를 공유할 수 있도록 관련 데이터들을 저장해 둔 데이터의 집합</li>
</ul>
<p>-DB를 구성하는 <strong>데이터들이 갖는 의미</strong></p>
<p><strong>공유 데이터</strong> : DB는 특정 조직의 여러 사용자가 함께 소유, 이용
<strong>통합 데이터</strong> : DB는 <strong>중복성 허용 X</strong>, 중복성 있으면 관리 어려움
<strong>저장 데이터</strong> : DB의 데이터는 컴이 접근할 수 있는 매체에 저장됨
<strong>운영 데이터</strong> : DB는 조직을 운영하고, 주요 기능을 수행하는 데 꼭 필요해 꾸준히 유지돼야 함 </p>
<p>-DB의 특징:</p>
<p><strong>동</strong>시 공유 가능
<strong>지</strong>속적인 변화_수정을 반영해 최신 상태를 유지 
<strong>실</strong>시간 접근 가능
<strong>내</strong>용 참조 가능_원하는 값만 제시하면 관련 데이터를 찾아줌</p>
<ul>
<li><strong>DBMS</strong> 데이터베이스 관리 시스템 : DB의 전반적인 관리를 담당하는 sw</li>
</ul>
<p>DB에서 데이터를 통합해 저장, 관리 / 응용프로그램을 대신해 DB에 존재하는 데이터의 검색,삽입,삭제,수정 기능을 수행 </p>
<p>-특징:
<strong>자료 접근성, 시스템 응답성 up</strong>
<strong>중앙집중적 자료 통제</strong>-모든 데이터가 한 곳에 저장돼 있어 통제 편함 
<strong>데이터 중복성 최소화</strong>
<strong>데이터 독립성 유지</strong>-다른 자료에 영향을 주지 않으며 자료의 구조를 변경할 수 있음
<strong>데이터 보안성 보장</strong>-자료가 한 곳에 저장돼 있어 보안 유지 좋음
<strong>데이터 일관성 유지</strong>
<strong>데이터 무결성 유지</strong>-제약 조건 만족시키는 값만 저장하게 함
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/c71611bb-eb87-4f8f-a87d-fe979cd7376d/image.png" /></p>
<p>-DB언어: DBMS을 구축하고, 관리하는 데 사용하는 언어</p>
<p>데이터 정의어 DDL : 데이터 저장 구조, 접근 방법, 형식 등 <strong>DB를 구축|수정</strong>할 때 사용하는 언어</p>
<p>데이터 조작어 DML: DB에 저장된 <strong>데이터를 검색,수정,삽입,삭제</strong>할 때 사용하는 언어 / 사용자-DBMS 간 인터페이스 제공함</p>
<p>데이터 제어어 DCL: <strong>데이터를 보호하고 관리</strong>할 때 사용하는 언어 / 데이터의 무결성 유지,시스템 장애 복구… </p>
<ul>
<li>데이터 모델 : <strong>데이터를 DB에 저장하는 구조</strong> / <strong>자료구조, 연산, 제약조건</strong>으로 구성됨</li>
</ul>
<p>ㅁ계층형 데이터 모델</p>
<p>레코드,링크로 구성된 트리구조, 부모-자식 형태의 정보를 링크로 연결해 표현함
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/ae5d7a3f-df92-4a0c-9c90-ae87cb45b60e/image.png" /></p>
<p>ㅁ네트워크형 데이터 모델 </p>
<p>DB를 <strong>그래프 형태</strong>로 구성한 모델, 계층형 데이터 모델과 달리 각 레코드가 여러개의 부모-자식 형태의 정보를 가질 수 있음
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/d065269c-005f-4412-aad6-bbe9f0dea6fc/image.png" /></p>
<p>ㅁ관계형 데이터 모델 RDB : 행,열로 구성된 2차원 테이블 형태 / 데이터 <strong>수정시 구조적 변경이 쉬움</strong>-가장 많이 쓰임</p>
<p><strong>관계형 데이터베이스</strong> : 관계형 데이터 모델을 기반으로 하는 데이터의 집합</p>
<p>2차원 테이블(각 행은 튜플=레코드, 각 열은 속성, 하나의 속성에 포함된 모든 값의 집합은 도메인_속성값들에 제한을 둘 수 있음)로 이뤄지며, 한 개체에 관한 데이터들은 <strong>릴레이션</strong>에 담김</p>
<p>-기본 용어: 
널 값_속성값을 모르거나,적합한 값이 없으면 적용되는 값 / 차수_한 릴레이션이 가지는 <strong>속성의 개수</strong>  / 카디널리티_한 릴레이션이 가지는 <strong>튜플의 개수</strong> /
키 : 각 튜플이 다른 값을 갖게 하는 속성의 모임 / RDB의 <strong>제약 조건을 정의함</strong> </p>
<pre><code>  슈퍼키: 유일성을 만족하는 속성|속성집합

  후보키: 유일성, **최소성**을 만족하는 속성집합 / 최소성은 꼭 필요한 속성들로만 키를 구성했다는 의미

  기본키: 후보키 중 기본으로 사용할 키, 하나의 튜플을 식별하는 역할

  대체키: 기본키로 선택되지 못한 후보키</code></pre><p>외래키: 다른 릴레이션의 기본키가 되는 어떤 릴레이션의 속성|속성집합 / <strong>외래키를 이용해 릴레이션들을 연결</strong></p>
<p>-관계형 DB의 <strong>제약</strong></p>
<p>무결성 제약조건: 사용자가 DB를 갱신시 <strong>DB의 일관성이 유지되도록</strong> 반드시 지켜져야 함 / 개체 무결성 제약조건&amp;&amp;참조 무결성 제약조건을 모두 만족해야 함 </p>
<p>  <strong>개체 무결성 제약조건</strong>: <strong>기본키</strong>를 구성하는 <strong>모든 속성은 널 값을 가지면 안됨 // 튜플의 유일성 판단을 위해</strong></p>
<p>  <strong>참조 무결성 제약조건</strong>: <strong>외래키</strong>는 <strong>참조할 수 있는 값</strong>만 가져야 함 //릴레이션을 연관시키기 위해</p>
<p>-관계형 데이터 <strong>연산</strong></p>
<p>  관계 대수 : 릴레이션을 처리하는 과정을 기술하는 언어 / 연산자들의 집합임
  (속성이 같아야 함) </p>
<p>   합집합 연산 : 두 릴레이션의 모든 튜플을 하나로 합치는 연산  릴1∪릴2
   교집합 연산 : 두 릴레이션이 모두 가지고 있는 튜플을 찾는 연산    릴1∩릴2
   차집합 연산 : 한 릴레이션에는 있지만 다른 릴레이션에는 없는 튜플을 구하는 연산    릴1-릴2 | 릴2-릴1
  카티션 곱 : 두 릴레이션의 <strong>튜플들의 모든 조합</strong>을 만드는 연산    릴1x릴2</p>
<p>  선택 연산: 릴레이션 내에서 조건을 만족하는 튜플을 구하는 연산 
  <img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/e66af53d-3f35-4fdb-9b31-5498df1d66d8/image.png" />
  추출 연산: 릴레이션에서 원하는 속성만 뽑는 연산
  <img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/406741f2-6804-435b-a3fc-b2350681a818/image.png" />
 조인 연산: 두 릴레이션이 공통으로 가지는 속성 중 특정 조건 에 맞춰 튜플들을 재구성함
 <img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/95142299-7021-41e9-949c-e9335fee9d42/image.png" />
 나누기 연산: 한 릴레이션에 있는 다른 릴레이션의 속성으로 특정 튜플을 뽑음 
 <img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/7abbde42-097c-4d18-b48a-222c97c50a18/image.png" />
-SQL: RDB를 사용할 때 쓰는 <strong>데이터베이스 질의용 언어</strong> / <strong>사용자와 DB의 매개체</strong>
 기능에 따른 구분: DDL,DML,DCL</p>
<pre><code>MySQL : 별도의 DBMS 서버를 운영해야 함
SQLite : 위 단점을 보완한 임베디드 RDB (응용 프로그램에 내장돼 작업을 수행함)</code></pre><p>ㅁ객체 지향형 데이터 모델</p>
<p>복잡한 데이터를 관리하기 위해 만들어진 모델, <strong>새로운 유형</strong>의 데이터 저장,분석,처리 작업을 지원함</p>
<p>ㅁ객체 <strong>관계형</strong> 데이터 모델</p>
<p>관계형 데이터 모델 &amp; 객체 지향형 데이터 모델 장점만 모아 만든 ****데이터 모델 </p>
<ul>
<li>빅데이터
: 기존의 DBMS로 처리하기 어려운 방대한 양의 정형|비정형 데이터들 의미
속성 3V: 규모, 속도, 다양성 </li>
</ul>
<p>빅데이터 기술: 많은 양의 데이터 중 <strong>가치 있는 정보를 선별</strong>해 <strong>결과를 분석하는 기술</strong> </p>
<p>빅데이터 처리 기술: 
<strong>빅데이터 소스 생성, 수집 기술</strong>_데이터는 소스 위치에 따라 내부 데이터 | 외부 데이터로 나뉨 (내부 데이터 수집, 외부 데이터 생성…)
<strong>빅데이터 저장 기술</strong>
<strong>빅데이터 처리 기술</strong>-하둡,R,NoSQL
<strong>빅데이터 분석 기술</strong>-텍스트마이닝,웹마이닝,오피니언마이닝,소셜네트워크분석,기계학습 등
<strong>빅데이터 표현 기술</strong>-데이터 분석 결과 표현
+데이터마이닝 : 텍스트마이닝_문서에서 의미 있는 정보 추출, 웹 마이닝_웹 방문 기록, 검색어로부터 정보 추출, 오피니언마이닝_사란들의 의견,감정 등을 분석</p>
<p>활용:</p>
<p>구글 트랜드 / 번역 / 수퍼컴퓨터</p>
<h3 id="데이터-통신과-모바일-컴퓨팅">데이터 통신과 모바일 컴퓨팅</h3>
<ul>
<li>데이터 통신: 원격지에 있는 송신자컴퓨터와 수신자컴 들을 유무선으로 연결해 <strong>데이터를 처리하고 전송하는 것</strong></li>
</ul>
<p>-특징: 고속화 / 대용량화 / 모바일화</p>
<p>ㅁ데이터 통신 기술: 데이터를 전송, 처리하는 기술</p>
<p>ㅁ디지털데이터 통신의 발전 과정: 전기를 이용한 전신기술 - 모스부호, 전산기 - 전화기 - 전자파 발견(Hz) - 전자파로 모스부호를 무선으로 보냄 - (최초의 컴퓨터 네트워크)반자동 방공망 시스템 - (<strong>최초의 패킷 교환망)</strong> 아르파 , 아르파넷_www의 시초 - TCP/IP 프로토콜 기반의 인터넷 - 컴네 속도 빨라지먀 데이터 전송률 증가, 다양한 종류의 멀티미디어 데이터 전송도 가능해짐 </p>
<ul>
<li>네트워크: <strong>전송매체를 통해 데이터를 교환</strong>하도록 구성한 시스템들의 집합체</li>
</ul>
<p>ㅁ프로토콜: 컴퓨터 네트워크에서 데이터를 주고받을 때 수행되는 절차//동등한 위치인 시스템들 간 규칙!
FTP / HTTP / TCP/IP </p>
<p>ㅁ데이터 전송을 위한 조건: 하드웨어 연결 + 프로토콜 정해져 있어야 함</p>
<p>ㅁOSI 7계층 모델:</p>
<p>배경: 많은 컴퓨터 제조 회사가 특징적인 네트워크 아키텍처를 발표해 호환성이 좋지 않아 폐쇄성이 강했음
국제 표준화 단체인 ISO에서 <strong>네트워크에 연결된 호스트가 갖춰야 할 기능</strong>을 상세히 정의함</p>
<div style="width: 55%; height: 450px; float: left;">
     네트워크에 연결된 호스트(컴퓨터, 네트워크)들은 모듈화(기능 단위로 분해하고, 추상화)된 통신 기능을 갖춰야 함 

<p><strong>각 계층</strong>은 자신이 담당하는 기능을 수행해 <strong>데이터가 안전하게 전달되게 함</strong></p>
<p>일반 사용자는 응용계층을 통해 데이터의 송신|수신 요청함</p>
<p><strong>데이터 송신화 호스트</strong>에선 응용 계층의 데이터가 순차적으로 전달돼 물리계층을 통해 상대 호스트에 전송됨</p>
<p><strong>데이터 수신화 호스트</strong>에선 물리계층의 데이터가 순차적으로 응용 계층까지 올라감</p>
</div>
<div style="width: 45%; height: 450px; float: right;">
  <figure>
      <img src="https://velog.velcdn.com/images/kimlj0814/post/7446dbe4-4579-4686-af55-105b1035fe2c/image.png" />
  </figure>
</div>

<p><strong>응용 계층</strong> : 기본적인 <strong>응용 기능</strong>을 제공_이메일,파일전송,분산 DB 관리 / 사용자에게 <strong>OSI 통신 환경</strong>을 제공</p>
<p><strong>표현 계층</strong> : 응용 계층의 <strong>데이터의 표현 형식을 관리</strong> </p>
<p><strong>세션 계층</strong> : 세션 연결을 지원(전송 계층에서 제공하는 연결 개념보다 더 상위의 논리적 연결) </p>
<p><strong>전송 계층</strong> : 정보의 <strong>운반 기능을 관리</strong> / <strong>송수신 프로세스 간 연결 기능 제공&amp;안전한 데이터 전송 지원</strong> </p>
<p><strong>네트워크 계층</strong> : <strong>데이터를 전송</strong>할 <strong>경로 선택</strong>과 <strong>중계 기능</strong> 수행</p>
<p><strong>데이터 링크 계층</strong> : <strong>중계시스템</strong>_단말기,교환기 <strong>간 데이터 전송에서</strong> <strong>오류 검출과 회복 기능</strong>을 제공</p>
<p><strong>물리 계층</strong> : OSI의 1계층, <strong>호스트</strong>를 <strong>전송 매체(회선)</strong>와 <strong>연결하기 위한 인터페이스 규칙</strong>, <strong>전송 매체의 특성</strong>을 다룸 </p>
<p>ㅁ데이터 전송의 유형:</p>
<p>-<strong>전송 방향</strong>에 따른 분류</p>
<p>단방향 전송 : 데이터를 한 방향으로만 전송하는 방식
반이중 전송 : 데이터가 양방향으로 전송되긴 하지만 <strong>한번에 한쪽으로만 전송하는 방식</strong> _동시에 전송 불가, 무전기
전이중 전송 : 양쪽에서 데이터를 전송하는 방식, <strong>하나의 전송 매체</strong>를 송신,수신 <strong>2개의 채널로 분할해 사용</strong></p>
<p>-<strong>회선 접속 방식</strong>에 따른 분류</p>
<p>점대점 전송: 통신장치를 <strong>일대일 방식</strong>으로 연결하는 전송 방식
다지점 전송: 여러 <strong>통신 장치</strong>가 <strong>하나의 회선을 공유하는 전송 방식</strong></p>
<p><strong>직렬 전송</strong> : <strong>하나의 통신 회선</strong>으로 2진수 데이터 비트를 <strong>1 비트씩 차례로</strong> 전송하는 방식
동기화: 송신자,수신자 간 정보를 주고 받을 <strong>비트 타이밍을 맞추는 절차</strong>
동기화 방법 : ****비동기식 전송, 동기식 전송</p>
<p><strong>병렬 전송</strong> : 각각의 데이터 비트에 연결된 통신 회선을 활용해 <strong>비트 블록을 한번에 전송하는 방식</strong>
비트 블록 == 하나의 문자를 표시하는 데 필요한 비트수, 거리가 짧은 데이터 통신에 활용됨<br />e.g. 8비트의 신호를 보내기 위해선 8개의 통신 회선이 필요</p>
<p>ㅁ<strong>통신 시스템 장치</strong>의 분류</p>
<p>-데이터 처리 장치 : 컴퓨터와 주변기기</p>
<p>-데이터 전송 장치 :    </p>
<p><strong>모뎀</strong>: 변조기+복조기 / 통신 장치를 통<strong>신회선에 접속시켜주는 장치</strong> / 컴퓨터의 디지털신호 ↔ 아날로그 신호</p>
<p><strong>통신 회선</strong>: 송신자, 수신자를 연결하는 <strong>물리적인 통로</strong>
구분: 유선 통신_꼬임 쌍선, 동축 케이블, 광섬유 / 무선 통신_마이크로파</p>
<p><strong>네트워크 카드</strong>: 빠른 속도로 <strong>외부 네트워크와 접속하고, 데이터를 주고받기 위해</strong> <strong>컴퓨터 내에 설치하는 확장 카드</strong> / 컨트롤칩,통신전용칩,버퍼로 구성됨</p>
<p><strong>허브</strong>: <strong>중앙 연결점</strong> / <strong>유선으로 연결된</strong> 여러 컴에서 데이터 공유시 사용하는 장치</p>
<p><strong>라우터</strong>: <strong>LAN과 LAN|WAN을 연결</strong>하는 네트워크 장치, 임의의 <strong>외부 네트워크와, 내부 네트워크를 연결함</strong> </p>
<p>ㅁ네트워크의 교환 방식</p>
<p>-회선 교환 네트워크: 호스트가 <strong>데이터를 전송하기 전에 연결 경로를 미리 설정</strong>하는 방식 / 독점으로 사용해 비효율적</p>
<p>-메시지 교환 네트워크: 경로를 미리 설정하지 않고, 메시지의 헤더에 목적지 주소를 표시해 전송하는 방식 / 교환기 단위로 전송함
-<strong>패킷 교환 네트워크</strong>: 메세지 교환 네트워크와 비슷하지만 패킷 단위로 데이터를 전송하는 방식 / 컴네 환경에서 주로 이용함</p>
<pre><code>‘ 가상 회선 방식: **모든 패킷이 하나의 경로**로 전송됨, 패킷이 도착하는 순서 == 전송한 순서

‘ 데이터그램 방식: 패킷을 **독립적으로 전송**, 패킷을 송신하기 전에 미리 경로를 부여하지 않음-패킷이 도착하는 순서 != 전송한 순서(일 수 있음)</code></pre><p>ㅁ네트워크의 분류</p>
<p>LAN 근거리 통신망: 한정된 범위에 분산된 컴퓨터를 <strong>통신 회선으로 연결한 네트워크</strong> </p>
<p>분류:</p>
<pre><code>-버스형: 하나의 통신 회선인 **버스**에 여러 장치들이 연결된 형태 / 한 장치가 데이터를 송신하면 버스를 통해 연결된 **모든 장치에 전송됨** / 수신자는 전송된 데이터의 수신자 주소를 확인해 **자신에게 보내진 데이터가 맞는지 확인후** 이를 받아들임 

-스타형: 중앙에 있는 **중개 호스트(허브)** 주위로 여러 장치를 연결한 형태 / 허브에 여러 장치를 **점대점 방식**으로 연결한 **중앙집중적 구조**라 유지보수가 쉽고, 전송제어가 간단함

-링형: 모든 기기를 **원형**으로 연결한 형태, 가까운 위치에 있는 노드 두개를 점대점 방식으로 연결해 **순환하는 구성** / 송신자가 보낸 패킷은 원을 따라 한 방향으로 흐르며, 목적지가 아닌 호스트를 지날 때마다 **재전송해 오류 down**

-메시형: 컴퓨터가 그물처럼 연결된 형태 / 중개점 역할을 하는 컴퓨터가 없이 직접 데이터 통신함

-트리형: 원점에서 1개 이상의 가지가 뻗어나와 복잡한 계층 형태로 퍼지는 구조 </code></pre><p>MAN : 도시권 통신망, LAN보다 넓은 범위에 있는 컴들을 연결한 네트워크</p>
<p>WAN : 광역 통신망, 국가 이상의 지역을 지원하는 구조, <strong>두개 이상의 LAN이 큰 규모로 연결된 네트워크</strong> / 속도는 LAN보다 느림 </p>
<h3 id="인터넷">인터넷</h3>
<p>: 많은 컴퓨터 사용자들이 접속돼 있는 거대한 컴퓨터 네트워크 = wan</p>
<p>ㅁ웹의 역사 : <strong>웹 시대 등장</strong>(www_최초의 웹 브라우저)→<strong>모자이크</strong>_그래픽 기반 웹브(www 확산에 도움)→<strong>네스케이프</strong>_최초의 상용화된 웹브→<strong>아마존,구글</strong> (검색엔진) →<strong>웹 이후    sns</strong> (의사소통을 위한 매체)   </p>
<p>ㅁwww : 하이퍼텍스트 기능을 활용해 인터넷의 다양한 정보를 쉽게 찾아볼 수 있게 한 <strong>광역 정보 서비스</strong> </p>
<p>-하이퍼텍스트: Link를 통해 개별 정보들을 유기적으로 연결해 <strong>비연속적, 비선형적으로 구성된 전자적 텍스트</strong></p>
<p>-URL : 웹에서 사용하는 <strong>표준 주소 표기 방식</strong> ==인터넷 주소 체계</p>
<pre><code>     표기법: 프로토콜명://사이트주소/파일디렉토리/파일명</code></pre><p>-IP 주소 : 인터넷에 연결된 기기를 식별할 수 있는 유일한 값 / 4B의 2진수 체계, 4개의 10진수로 표현  </p>
<p>IPv4를 사용하다가 인터넷에 연결된 기기의 개수가 증가하며  IP주소가 부족해지고 IPv6로 대체될 것이라 전망</p>
<p>+공유기는 공유기와 인터넷 사이인 외부에선 공인 IP / 각 단말로 연결되는 부분인 내부에선 사설 IP를 사용해 
하나의 IP로 여러대의 컴퓨터가 동시에 인터넷을 할 수 있게 함 </p>
<p>-도메인 네임 : IP주소를 쉽게 영문으로 표현 
ㄴDNS가 개발되며 문자로 된 주소를 사용할 수 있게 됨 </p>
<p><strong>http</strong>://<strong>www</strong>.<strong>웹사이트이름</strong>.<strong>ac</strong>.<strong>kr</strong></p>
<pre><code>프로토콜 이름: http는 하이퍼트랜스퍼프로토콜_HTML|XML문서를 주고받기 위한 프로토콜
컴퓨터 이름: www 라는 컴에 접속한다는 뜻
도메인 이름: 해당 웹 사이트의 이름
도메인 성격: 웹사이트의 **성격**. 표준화된 국제적 지침을 따라야 함 
국가 이름: 국제적 지침에 따라 사용해야 함, 대한민국은 kr 사용함 </code></pre><p>+https는 http에 데이터 암호화가 추가된 프로토콜임, 네트워크 상에서 중간에 제 3자가 정보를 볼 수 없도록 암호화됨 </p>
<p>-클라이언트-서버 구조 : 사용자가 <strong>서버의 정보를 검색</strong>하기 위해 사용해온 모델 / 웹을 적용한 클라이언트/서버가</p>
<p>웹 클라이언트 : 웹 브라우저를 통해 데이터를 요청 (HTTP Request)</p>
<p>웹 서버 : 웹 클라이언트 요청에 응답해 정보를 제공 (HTTP Response)</p>
<p>+웹 브라우저 : <strong>HTML문서를 읽고</strong> <strong>웹 페이지에 정보를 표시</strong>하는 sw (HTML interpreter) _크롬, 사파리</p>
<p>-TCP/IP : 서로 다른 컴퓨터를 연결해 데이터를 전송하기 위해 사용하는 <strong>통신 프로토콜의 집합</strong> / 운영체제의 일부로 구현되며, 응용 프로그램은 운영체제가 제공하는 TCP/IP 프로토콜을 사용</p>
<p> 통신 프로토콜 : 호스트-라우터, 라우터-라우터, 호스트-호스트가 <strong>통신할 때 따라야 하는 절차</strong> </p>
<p> 계층:</p>
<p>응용 : 다수의 <strong>프로토콜</strong> &amp;&amp; 이 프로토콜을 사용하는 <strong>응용 프로그램</strong> </p>
<p>전송 : <strong>최종 통신 목적지를 지정</strong>하고 오류 없이 <strong>데이터를 전송하는 역할</strong> </p>
<p>인터넷 : 데이터를 <strong>목적지 호스트까지 전달 _IP 프로토콜 이용</strong></p>
<p>네트워크 : 물리적 네트워크를 통한 <strong>실제 데이터 송수신 담당</strong></p>
<p>-FTP : 인터넷을 통해 <strong>파일을 송수신</strong>하기 위한 프로토콜 / 운영체제에서 기본적으로 제공</p>
<p>-HTML(hypertext markup language) : 웹을 이용해 문서를 작성할 때 사용하는 언어 / HTML5_웹 표준안, HTML의 최근 버전</p>
<p>웹 프로그래밍==HTML을 이용한 문서 제작</p>
<h3 id="모바일-컴퓨팅">모바일 컴퓨팅</h3>
<p>: 모바일 기기를 이용해 언제 어디서나 컴퓨터를 다룬다는 의미</p>
<p>-모바일 기술 요소: <strong>컨텐츠</strong>, <strong>플랫폼</strong>_모바일 서비스 운영에 쓰는 sw, <strong>기기</strong>, <strong>네트워크</strong>_모바일 기기를 통해 접속할 수 있는 통신망
-모바일 컴퓨팅을 가능하게 하는 필수 조건 : 고속 네트워크, 모바일 hw,sw </p>
<p>-모바일 운영체제 : 안드로이드_리눅스 기반 , ios</p>
<p>-무선 네트워크 기술 : <strong>이동 통신_고주파를 이용</strong>해 모바일 기기에서 데이터를 전송할 수 있게 함 / <strong>와이파이</strong><em>전자기기들을 <strong>무선 LAN에 연결하는 기술</strong> / 무선 PAN</em><strong>근거리에 있는 모바일 기기 간 데이터를 송수신</strong>할 수 있는 기술=무선 개인 근거리 통신망 기술 :</p>
<p>블루투스_유선 연결 대체제, 장애물이 있어도 통신 가능, 전력소모 낮음  / NFC_근거리에서 <strong>양방향 통신</strong>이 가능하게 한  <strong>RFID 기술</strong> / 지그비_저속,저비용,저전력의 무선 네트워크 기술 / 와이기그_와이파이보다 높은 주파수를 사용해 빠른 속도 제공</p>
<h3 id="사물-인터넷">사물 인터넷</h3>
<p>: 각종 물체에 센서, 통신 기능을 내장해 <strong>인터넷에 연결하는 기술</strong> </p>
<p>-기술
센싱 기술: <strong>사물이 가진 데이터</strong>를 인식하고, 추출해 <strong>인터넷으로 전송</strong>하는 기술 
유무선 네트워크 기술: <strong>분산된 컴퓨팅 자원</strong>을 <strong>유무선 통신으로 연결해</strong> <strong>고속,병렬 처리</strong>하는 기술 
서비스 인터페이스 기술: 각종 서비스에 맞게 정보를 가공,처리,융합하는 기술 </p>
<p>보안 기술: 사물인터넷 구성요소에 대한 해킹이나 정보 유출을 방지하기 위한 기술 / 개인정보 보호를 위해 중요하게 다뤄져야 할 기술임</p>
<p>-활용: 스마트 홈, 스마트 교통, 스마트 헬스, 스마트 에너지 </p>
<h3 id="멀티미디어">멀티미디어</h3>
<p>다양한 형식의 미디어 데이터, ICT 기술을 이용해 사용자와 상호작용하며 정보를 제공하는 미디어 </p>
<p>-분류: 표현 미디어_데이터 생성과 관련된 미디어(콘텐츠)/저장 미디어_저장 매체(HDD,SDD)/전송 미디어_통신망(5G)/제시 미디어_출력장치(모니터,HMD)/지각 미디어_시각,청각,촉각</p>
<p>-특징: </p>
<p><strong>디지털화</strong>: 멀티미디어는 컴퓨터를 통해 정보를 다루므로 모든 정보가 디지털 신호로 처리됨
<strong>통합화</strong>: 다양한 미디어를 동시에 활용함
<strong>영상화</strong>: 다양한 형태의 정보들이 보통 영상으로 표현됨
<strong>쌍방향성</strong>: 정보가 쌍방향으로 전송돼, 정보 제공자와 사용자가 <strong>상호작용</strong> 해 새 정보를 만들 수 있음 
<strong>비동기화</strong>: 정보 제공자와 수용자가 동시에 참여할 필요가 없어, <strong>시공간적 제약이 없음</strong> </p>
<p>-구성요소: </p>
<p>텍스트 : 가장 많이 사용하는 데이터 형식, 다른 멀티미디어 데이터보다 적은 용량 처지
코드 시스템 : 정해진 규칙에 따라 이진코드를 각 문자에 할당한 것
아스키 코드 / 유니코드_모든 언어 표현 가능
파일 형식 : 
TXT /      HWP /DOCX _문서 서식,글꼴 등도 함께 저장 / PDF_문서 형태를 그대로 유지, 자체적인 압축 기능 있어 온오프라인에서 쉽게 문서 공유 가능 (파일의 무결성, 호환성, 보안이 뛰어남)</p>
<p>이미지 : 스캐너|디카를 통해 입력된 시각 정보, 2차원 평면에 픽셀단위로 표현됨
표현 형식: 비트맵 방식 / 벡터 방식 _추가적인 랜더링 필요(2차원 출력장치)
컬러 모델: RGB_전자기기 /CMYK_인쇄 
파일 형식: BMP / JPEG_국제 표준 사진 압축 알고리즘, 현재 웹 인쇄 분야에서 가장 많이 사용됨 / GIF_온라인 전송을 위한 형식, 무손실 압축 사용, 색상 팔레트 사용 / PNG_GIF를 대체하기 위한 파일 형식, 트루컬러 사용</p>
<p>에니메이션 : 연속적인 프레임으로 움직이는 것처럼 보이게 만드는 촬영기법|영화
전통적 애니메이션: 셀 애니메이션
디지털 애니메이션: 이미지들을 결합해 연속적으로 움직이는 것처럼 보이게 구현하는 기술_자동으로 
파일형식: GIF_하나의 파일에 여러개의 이미지를 저장해 이미지 순서, 지속 시간, 반복횟수를 나타내는 파일 형식</p>
<p>사운드 : 
구성요소: 
사운드: 공기를 매개로 진동하는 파동 형태==음파
사이클: 같은 모양으로 나타나는 파형
주기: 하나의 사이클에서 음파의 변화가 한 번 반복되는 시간
주파수: 1초당 주기의 수==주기 값의 역수==진동수(단위는 Hz) / 높을수록 고음 (소리의 높낮이 결정)
진폭: 기준선에서 파형의 최고점까지의 거리 (소리의 크기 결정) 
음색: 파형의 고유한 특징, 음의 주파수가 같아도 음파의 모양이 달라서 나타남
파일 형식: wave_개인용 컴에서 사운드 녹음,재생할 때 사용, <strong>압축 X</strong> / midi_컴으로 악기를 연주하기 위한 파일 형식 / mp3_<strong>손실</strong> 압축 포맷, 사운드 데이터 저장용 / wma_<strong>음악 데이터 압축 방식</strong>, 용량이 MP3의 절반 정도</p>
<p>비디오 : 순차적으로 정지 화면이 재생되는 정지 영상 구조
프레임: 정지 영상 하나, 인접한 프레임은 유사함
대역폭: <strong>단위 시간당(초당) 데이터 전송량</strong>
초당 프레임 수: 비디오에서 <strong>프레임이 바뀌는 속도</strong>
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/048ac180-ac64-490b-b796-f54028716e9e/image.png" />
<strong>비디오 압축</strong>: 영상 데이터의 용량 down, <strong>압축된 데이터를 복원하는 과정</strong>에서 영상의 품질이 떨어지지 않는 게 중요 
영상을 재생할 땐 <strong>코덱 과정</strong>을 거침 : 디지털데이터로 변환된 정보를 압축해 용량을 줄이는 인코딩 / 인코딩된 데이터를 다시 복원해 출력하는 디코딩 작업 </p>
<p>-활용 분야: 
비즈니스, 여행시스템, 교육훈련, 엔터테인먼트, 연구개발 </p>
<p>-응용 기술:
컴퓨터 그래픽스: 컴퓨터를 사용해 제작된 이미지 &amp;&amp; 이를 구현하는 기술 
3차원 컴퓨터 그래픽스: 컴그를 3차원으로 표현한 기술 
제작 과정: 모델링 - 조명을 비춰 음영 처리, 질감 넣음 - 랜더링
표현 방식: 폴리곤_3D 모델의 표면을 삼각형(다각형)으로 구성하는 방식 / 넙스_적은 개수의 제어점으로 매끄러운 곡선을 표현하는 스플라인을 사용 
가상현실 : 가상공간에서 인간의 감각이 기계와 상호작용 해 몰입감을 느낄 수 있게 한 기술
증강현실 : 실제 환경에 가상 사물을 합성해 하나의 영상으로 보여 주는 컴퓨터 그래픽 기법</p>
<ul>
<li>멀티미디어 시스템: 멀티미디어 정보를 처리하는 컴퓨터|컴퓨팅 기기</li>
</ul>
<p>-하드웨어:
입력장치: 디지타이저, 터치스크린-위치값이 디지털화됨
출력장치: HMD, 프로젝터_공간에 콘텐츠를 증강시킴 
저장장치
미디어 처리장치: <strong>그래픽 카드</strong>_데이터를 모니터에 전달해주는 장치, <strong>사운드 카드</strong>_외부 스피커를 통해 더 좋은 음향을 출력하는 장치 </p>
<p>-소프트웨어:</p>
<p>운영체제: <strong>연속적 미디어 데이터</strong>를 처리하기 위해 <strong>추가 서비스를 제공</strong>함 </p>
<p><strong>실시간 처리</strong>: 데이터를 특정 시간 안에 처리
<strong>대용량 데이터 처리</strong>: 압축 기법을 사용해 데이터의 용량을 줄임
<strong>데이터의 관계성에 따른 처리</strong>: <strong>시공간적 연관성</strong>에 따라 처리 
<strong>데이터 품질의 가변성에 따른 처리</strong>: 해상도|초당 전송 프레임수를 조정해 데이터 용량을 통신 회선의 전송 능력에 맞춤 </p>
<ul>
<li>실감 미디어</li>
</ul>
<p>: <strong>실제로 체험하는 느낌을 제공하기 위한 서비스 전체</strong></p>
<p><strong>인간의 오감을 만족시키는 방향으로 발전 중</strong>
<strong>CPND</strong> : 콘텐츠<em>고차원.고용량/플랫폼</em><strong>서비스 호환성</strong>/네트워크_고속 유무선 전송/디바이스_고성능 센서.입출력 지원</p>
<p>특징: 사실감/현장감/몰입감/입체감
실감 콘텐츠: 사람들에게 실제로 유사한 체험을 하게 하는 디지털 콘텐츠
e.g. 실감형 게임, 영화, 공연, 업무, 운동…</p>
<p>ㅁ(고성능) 영상 미디어</p>
<p>촬영-저장-편집-CG-합성-압축-배포-후반작업-디스플레이 까지 <strong>전 단계에서 성능을 지원해야 함</strong></p>
<p>구성요소:
<strong>해상도</strong>: 디스플레이|영상의 가로,세로에 배치된 픽셀의 개수 / 다양한 규격 존재
<strong>프레임 레이트</strong> : 디스플레이|영상이 <strong>프레임을 표시하는 빈도</strong>
영상에선 FPS단위로 표현 / 디스플레이에선 Hz 단위로 표현
프레임 레이트에 비례해 사실감,용량 up 
<strong>시야각</strong> : 사용자의 시점으로부터 <strong>디스플레이가 차지하는 각도</strong> 
<strong>화면 크기&amp;시청 거리</strong>로 시야각이 결정됨
시야각에 비례해 몰입감 UP-해상도도 함께 높아져야 선명도가 유지됨 
<strong>명암비</strong> : 디스플레이의 <strong>최대 휘도(W)와 최소 휘도(B) 차이를 수치로 표현</strong>한 것
화질을 결정하는 주요요소-명암비에 비례해 사실감 UP
<strong>비트 심도</strong> : 디스플레이|영상이 표현할 수 있는 <strong>색상의 수</strong>를 나타내는 수치
높을수록 다양하고 사실적인 색 표현 가능 / 명암비도 UP → 화질을 결정하는 주요요소
<strong>색 영역</strong> : 디스플레이에서 표현 다능한 색상의 <strong>범위</strong>
ㅁ입체 영상 미디어(3D 입체 영상)</p>
<p>-구현 원리:</p>
<p>사람의 입체감 지각 원리 : <strong>양안시차</strong> 때문에 다른 이미지를 보고 하나로 합쳐지는 과정에서 입체감을 느낌
입체 영상 구현 원리 : 2개의 카메라 렌즈로 좌우 영상 동시에 촬영, 좌우 눈에 대응하는 영상을 각각 재생함</p>
<p>-제작 방법:</p>
<p><strong>직접 촬영 방식</strong> : 가장 오래된 기술, 같은 사양의 카메라 2대를 리그(받침대) 위에 올려 실사 촬영 
수평 방식-두 카메라의 거리가 사람의 눈과 일치하기 힘듦 → <strong>수직 방식</strong>-카메라 사이에 <strong>미러</strong>를 넣어 앞 문제 해결<br />문제: 기동성 떨어짐, 카메라의 수평이 일치해야 함, 촬영이 동기화돼야 함 </p>
<p><strong>CG 제작 방식</strong> : CG 데이터를 <strong>가상카메라로 2번 렌더링해 합쳐서 입체 영상 만듦</strong>
장_직접 촬영 방식보다 <strong>사전 시뮬레이션이 용이</strong>, <strong>카메라 정렬&amp;동기화 이슈X</strong> / 단_2회 랜더링에 따른 비용</p>
<p><strong>2D-to-3D 변환 방식</strong> : 일반 영상을 입체 영상으로 변환하는 방식 / 작업 방식:실시간 자동 변환, 수작업 혼합, 완전 수작업
장_일반 영상 파이프라인 그대로 활용 가능 / 단_수작업은 비용 큼, 자동 변환은 일반 영상으로부터 추출된 <strong>깊이 영상</strong>의 품질에 영향을 받음</p>
<p>-입체 영상 <strong>파일 포맷</strong>: L,R 분리된 일련의 프레임 저장</p>
<p>-입체 영상 <strong>디스플레이 방식</strong>:
좌우 영상을 분리해 각 눈에 표시하기 위한 방식
애너글리프: 가장 오래됨, <strong>적</strong>_우,<strong>청</strong>_좌 <strong>안경</strong>을 쓰고 보는 방식
편광: 디스플레이에 <strong>편광 필터</strong>를 활용해, <strong>입체 영상을 좌,우 영상으로 분리</strong>, 사용자는 <strong>편광 필터 안경</strong>을 쓰고 감상-현재 영화
셔터: <strong>전자적인 제어 장치가 탑재된 셔터 안경</strong>으로 <strong>디스플레이와 동기화해</strong> 보는 방식-해상도가 좋음</p>
<p>ㅁ가상현실</p>
<p>-기술적 특징:
3차원 입체 영상
넓은 시야각 디스플레이_현장감, 몰입감을 위해
사용자 시점 실시간 랜더링
실시간 상호작용성<br />-시스템의 형태:</p>
<p><strong>광 시야각 디스플레이 기반 가상현실</strong> : 하나의 대형 광 시야각 디스플레이 시스템을 만듦 / <strong>다수의 디스플레이 간의 랜더링 동기화</strong>가 중요</p>
<p><strong>HMD 기반 가상현실</strong> : 디스플레이가 내장된 고글형 장치 / 사용자의 머리회전에 따라 <strong>렌즈 왜곡을 고려해</strong> 랜더링 수행</p>
<p>-실시간 <strong>사용자 동작 인식 원리</strong>:
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/a62f26e9-1655-4649-b5e3-45fcd1ed68ce/image.png" /></p>
<pre><code>Inertial Tracking : 장치에 내장된 자이로스코프 센서&amp;가속도 센서로 사용자의 머리 방향을 추적 / 가장 많이 씀 / 3자유도 제공

Outside-in Tracking : 주변에 카메라를 설치하고 사람에게 부착된 적외선 마커를 인식해 머리방향, 위치 인식 / 6자유도 

Inside-out Tracking : 장치에 여러 카메라를 내장해 변하는 주변환경으로 사용자의 머리방향, 위치 인식 / 6자유도</code></pre><h3 id="인공지능">인공지능</h3>
<p>: 인간의 지적능력을 컴퓨터로 구현하는 방법에 대해 연구하는 <strong>ICT 기술</strong>
목적: 컴퓨터가 인간의 지능적인 행동을 모방하게 함 </p>
<p>+인공지능적 문제해결에 대한 고찰 
e.g. 방정식 풀 떄
사람 : 근의 공식, 인수분해, 가능한 값 대입해봄
인공지능 : 사람의 해법을 프로그램으로 구현하는 건 인공지능이라 할 수 없음 | 약인공지능엔 해당함  →  어디까지가 인공지능인지 정의하는 게 어려움 </p>
<ul>
<li>종류</li>
</ul>
<p>-강인공지능: 인간과 유사한 지능을 가지고 <strong>인간과 유사한 방법으로 일을 수행</strong>하는 자동화 시스템
-약인공지능: 인간의 <strong>행동의 결과를 모방</strong>하는 시스템, 인간과 <strong>다른 방법을 사용해도 같은 결과만 구현해내면 됨</strong>  e.g. 얼굴인식, 현재 사용되는 대부분의 ai기술</p>
<ul>
<li>튜링 테스트</li>
</ul>
<p>: 기계가 지능을 갖고 있는지 아닌지를 판별하고자 만든 테스트
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/a5f8758f-d70f-4223-b036-498acecd3fe3/image.png" /></p>
<ul>
<li>역사</li>
</ul>
<p>최초의 <strong>신경망</strong> 컴퓨터 만듦 → 튜링테스트→인공지능 단어 사용→ (침체기) 인공신경망 ‘퍼셉트론’의 한계 → (부흥기) ‘오차 역전파법 알고리즘’ 의 등장 → 현재 초대형 IT 기업들이 인공지능 연구에 집중함 </p>
<ul>
<li>세부분야</li>
</ul>
<p>-지식: 정보를 체계화한 것</p>
<p>-지식 표현: 지식을 <strong>사용하기 쉽게 표현</strong>하는 방법을 연구하는 분야
<strong>의미 네트워크 방법</strong> : 네트워크 표현으로 개체들의 관계를 표현하는 방식</p>
<p>_자연어 처리에서 나온 해석 결과, 질문 응답 시스템의 지식 표현에 사용  </p>
<p><strong>프레임 기반 방법</strong> : 개체의 특징을 <strong>슬롯</strong>(슬롯 이름)으로 구성해 두고, </p>
<p>새로운 개체의 특징으로 슬롯 값을 채우는 표현 방법</p>
<p>_데이터가 복잡, 방대한 경우 쓰기 좋음</p>
<p><strong>규칙 기반 방법</strong> : 조건과 결론을 표현하는 <strong>규칙</strong>들을 추론해 새로운 <strong>사실</strong>을 생성하는 방법</p>
<p>_전문가 시스템</p>
<p>-전문가 시스템: 전문가의 지식을 모델링해 <strong>지원하는 시스템</strong></p>
<p>구성:</p>
<p><strong>지식 기반</strong>: 지식의 모음 / 지식의 형태에 따라 다른 지식 표현 방법을 사용 / 지식은 사실|규칙_사실들의 관계에 대한 설명</p>
<p><strong>추론엔진</strong>: 지식을 기반으로 지식을 새롭게 생성함</p>
<p><strong>사용자 인터페이스</strong>: 질의 입력, 출력
-탐색: <strong>문제 공간 내</strong>에서 적합한 해답을 찾아가는 해결 방법</p>
<p>트리 기반의 탐색 기법 활발히 사용_게임트리가 대표적 </p>
<ul>
<li>기계학습 (머신러닝)
: 기계가 데이터를 이용해 <strong>스스로 학습</strong>해 <strong>문제를 해결</strong>하는 인공지능의 한 분야</li>
</ul>
<p>목적 <strong>: 인간의 학습 능력</strong>을 컴퓨터로 구현하고자 함  </p>
<p>기계학습 연구가 활발히 진행된 이유: <strong>자동화 촉진됨</strong>, <strong>학습 모델링</strong>_기계를 학습하다보면 사람의 학습 과정을 알아낼 수 있음, <strong>다양한 분야와의 관련성</strong></p>
<p>-종류:</p>
<p><strong>지도학습</strong>: <strong>정답이 있는 학습데이터</strong>에서 패턴을 찾아내는 것
-분류: 입력 대상이 속한 군집을 식별
-회귀 분석: 입력 데이터을 표현할 수 있는 <strong>함수</strong>를 구함</p>
<p><strong>비지도학습</strong>: <strong>정답이 없는 데이터</strong>로부터 패턴을 찾는 것 
-클러스터링: 데이터를 몇몇 그룹으로 나눔</p>
<p><strong>강화학습</strong>: 학습 알고리즘이 수행한 행동에 대해 <strong>보상과 벌</strong>을 받으며, 보상을 최대화하도록 학습하는 방법
기계는 보상을 받으면 <strong>이를 일련의 행동에 대해 나누고</strong>, 지도학습을 위한 <strong>학습 데이터로 사용함</strong> </p>
<ul>
<li>인공신경망</li>
</ul>
<p>: 인간 뇌의 작동 방식을 본뜬 학습 기법 (뉴런,시냅스) </p>
<p>입력층 노드에 데이터가 입력되면 오른쪽 방향으로 <strong>단계별 연산</strong>을 수행해 출력층에서 결과값을 얻음</p>
<p>-<strong>퍼셉트론</strong>: 지도 학습 신경망/ 생물의 신경전달 조직 ‘<strong>시냅스</strong>’를 <strong>수학적으로 모델링</strong>한 <strong>신경망의 초기 형태</strong></p>
<p><em>퍼셉트론 하나만 사용하면 직선 함수를 얻을 수 있음</em></p>
<p>가중치(w): 데이터 값의 강도 
편향(b): 가중합이 더 크면 1을 출력하게 하는 임계값
활성화 함수: 출력값을 일정 범위의 값으로 조절해 <strong>최종 출력값을 결정하는 함수</strong> / 단위 계단 함수임 </p>
<p>활성화 함수의 결과가 0이상이면 1을 출력하고, 0보다 작으면 0을 출력함, 이 값이 다음 퍼셉트론의 입력으로 사용됨, 이 과정을 반복하며 학습함
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/b1554bd2-4cc5-4f78-be6e-07e398f898c3/image.png" />
-다층 퍼셉트론: 입력층과 출력층 사이에 은닉층이 많은 퍼셉트론 </p>
<p><em>퍼셉트론을 여러개 사용해 비선형적인 정확한 함수를 얻을 수 있음</em></p>
<p><strong>학습 방법</strong>: 정답이 포함된 데이터로 가중치를 구하고, 인공신경망에서의 미분을 계산해 손실함수를 최소화하는 가중치를 계산해 나감, 이때 오차역전파법을 활용하면 학습을 더 효율적으로 할 수 있음
<img alt="업로드중.." src="blob:https://velog.io/fed420c3-47a2-403f-9cad-43ba1d44a614" /></p>