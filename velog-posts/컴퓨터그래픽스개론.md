<p>비교 : 레스터 그래픽스-벡터 그래픽스 , 애니메이션-가상현실, 벡터 모니터-래스터 모니터, 선 그리기 알고리즘끼리, 원 그리기 알고리즘끼리, 이웃한 픽셀 연결 방식, 다각형 내부 판단 규칙, 시드채우기 방식-다각형 주사 변환 방식, 내부 영역 판단 방식, 래스터폰트-벡터 폰트, 수퍼 샘플링-영역샘플링</p>
<h3 id="2차원-그래픽스">2차원 그래픽스</h3>
<p>: 점, 선, 다각형, 원, 곡선 같은 기본 도형으로 2차원 평면상에 그림을 그림 (출력요소)</p>
<p>입력 좌표가 x,y 인 2차원 정보로 주어짐, 평면 공간에서의 변환으로 조작됨
결과물을 픽셀 형태로 표현 == 2차원 정보로 표현
그래픽의 생성, 처리, 출력과정이 단순해 프로세서가 쉽게 그래픽 처리 가능</p>
<p>(배경지식)
픽셀 : 그림의 가장 작은 구성 단위 / 각 픽셀이 담는 다양한 형태의 정보_RGB, Grayscale / 크기_비트, 바이트
이미지 : 해상도 / 파일 크기
동영상 : 압축</p>
<p>(그래픽의 표현,처리 방법에 따라)</p>
<p>ㅁ 벡터 그래픽스 : 그래픽에 사용된 객체들을 벡터 데이터 조합과 수식으로 나타내고, 그래픽 명령어를 기억장치에 저장하는 방식
ex) 직선==직선 그리는 함수, 두 끝 점의 좌표 / 원==원 그리기 함수, 반지름
-픽셀의 개념이 없음
-래스터 그래픽 방식으로 저장한 것보다 파일의 크기가 작음 / 화면 확대해도 화질의 변화가 없음_기하적 객체를 수식으로 표현하므로, 하지만 파일의 크기가 증가함
벡터 그래픽스 sw는 수학적 계산으로 표현되는 객체로 이미지를 처리하는 것임</p>
<p>ex) 2_illustrator,Corel Draw / 3_Maya,3DMax (내부적으로 벡터 그래픽스 방식을 따름)</p>
<p>-레스터화 : 벡터 그래픽스로 표현된 데이터를 레스터 그래픽스로 변경하는 과정 _렌더링</p>
<p>ㅁ 래스터 그래픽스==비트맵 그래픽스 : 그래픽 데이터를 픽셀 단위의 2|3차원 배열로 나타내고, 그래픽의 픽셀값을 기억장치에 저장
-파일의 크기는 출력장치의 해상도에 비례함 / 화면을 확대하면 화질이 떨어짐_픽셀들의 크기만 커지므로, 파일 크기는 변하지 않음
레스터 그래픽스 sw는 픽셀로 표현되는 객체로 이미지를 처리하는 것임</p>
<p>ex) 2_photoshop, Painter / 3_3차원 초음파, CT</p>
<p>-벡터화 : 레스터 그래픽스 → 벡터 그래픽스 _3차원 CT 영상을 3차원 벡터 데이터로 변경하는 마칭큐브방법</p>
<p><img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/9cfac51a-7f81-42af-8e7f-9e2e1b515c7c/image.png" /></p>
<p>그래픽스의 활용용도, 목적에 따라 결정됨</p>
<p>2차원 그래픽스의 기본 요소</p>
<p>ㅁ 점과 선</p>
<p>o 점</p>
<p>기하적 공간에서 좌표(x,y)로 정의_실수임
출력장치에선 픽셀의 좌표로 변환됨
속성: 크기, 명암(intensity), 색상, 모양
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/0185350e-b624-4931-b546-aa7b790302a7/image.png" /></p>
<p>o 선</p>
<p>시작점(xa,ya)과 끝점(xb.yb)의 절대좌표(고정돼있고 하나밖에 없음)로 정의 |
시작점 좌표(절대좌표)와 좌표의 증가값의 상대좌표로 정의</p>
<p><img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/e5811e71-e80e-4878-885d-c9360d8b5220/image.png" />
속성: 선 유형, 굵기, 색상, 선끝 모양(line cap)</p>
<p>+다중선: 연속적으로 연결된 여러 선의 집합임
속성으로 선 이음(line join)이 추가됨</p>
<p>(현재 사용하는 모니터는 대부분 래스터 출력장치 // 출력요소의 정의로부터 래스터 방식의 그림으로 변환시키는 주사 변환 알고리즘 필요)</p>
<p>o DDA(Digital Differential Analyzer) 선 그리기 알고리즘</p>
<p>선의 양끝 좌표로부터 래스터 출력장치로 변환하는 가장 기본적인 알고리즘
(레스터 출력장치여도 벡터 방식을 활용함 ex) 어느 범위까지 색칠할 것인가 )</p>
<p>y=mx+c 선의 공식
0≤m≤1 x++ ⇒ y+=m , x++
m&gt;1 y++ ⇒ x+=1/m , y++ //y방향으로 증가되는 값인 m이 1보다 크므로 픽셀 사이가 끊겨서
-1≤m&lt;0 x++ ⇒ y-=m, x++
m&lt; -1 y++ ⇒ x-=1/m , y++</p>
<p><img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/7b5ce0e1-6c0c-4e9b-8c19-501cab8be337/image.png" /></p>
<p>특징: 곱셈 없음, 소수점(floating point) 덧셈만 반복 / 매번 정수좌표를 구할 때마다 오차가 축적됨</p>
<p>~ 컴퓨터 그래픽 초반부</p>
<p>o Bresenham 선 그리기 알고리즘</p>
<p>: m이 0과 1 사이일 때, 선을 구성하고 있는 어느 한 점의 다음 점은 반드시 오른쪽 점 | 오른쪽 바로 위의 점임
소수점 계산 없이
정수 덧셈 연산과, 시프트 연산(진수가 자리만 움직임)만으로 처리 → 오차 적고, 속도가 빠름</p>
<p>가장 많이 쓰임</p>
<p>(확장)
선분의 기울기 m이 0≤m≤1 이면
선을 구성하는 한 점의 다음 점은 오른쪽 점이나, 오른쪽 바로 아래 점
선분의 기울기 m 이 m&gt;1 이면
선을 구성하는 한 점의 다음 점은 위 점이나, 오른쪽 대각선에 있는 점
선분의 기울기 m이 -1≤m&lt;0 이면
선을 구성하는 한 점의 다음 점은 왼쪽 점이나, 왼쪽 바로 아래 점
선분의 기울기 m이 m&lt; -1 이면
선을 구성하는 한 점의 다음 점은 아래 점이나, 왼쪽 대각선에 있는 점</p>
<p>ㅁ 원, 타원 및 기타 곡선</p>
<p>o 원 그리기</p>
<p>-극 좌표계를 이용하는 방법 (일정 간격의 선 조각을 연결해 그림)
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/26af3a31-0eb4-4ffc-8dc8-d1a90b91e76a/image.png" /></p>
<p>(xc,yc)는 원의 중심 / 기울기의 절댓값이 0과 1사이인 경우에 픽셀점을 구해 대칭 성질로 원 완성
계산이 비효율적임</p>
<p>-Bresenham 원 그리기 알고리즘</p>
<p>제곱근, 삼각함수 계산 없이 정수 연산만으로 출력할 픽셀들을 구함 → 속도가 빠름
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/040e5a92-6a39-4886-b08b-f1f0bc27153c/image.png" /></p>
<p>o 타원 그리기
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/b18e5317-c02f-4708-a88e-fcfdf20cd54c/image.png" /></p>
<p>+타원 그리기에도 Bresenham 알고리즘을 적용해 효율적으로 픽셀들을 그릴 수 있음</p>
<p>o 기타 곡선</p>
<p>함수 y=f(x)로 표현 가능한 곡선
적당한 간격의 x값에 해당하는 곡선 상의 점을 구한 후 선분으로 연결</p>
<p>곡선 상 픽셀의 접선의 기울기가 |m|≤1 이면 f(x)에서 x값을 1씩 증가시키며 y값 구함 |m|&gt;1이면 f-1(y)에서 y값 증가시키며 x값을 계산하며 곡선을 그림</p>
<p>삼각함수, 지수함수, 다항식 함수, 스플라인 함수(여러개의 제어점을 통과하는 부드러운 곡선으로, 인접한 두 점 사이 구간마다 별도의 다항식을 이용해 곡선을 정의함) …</p>
<p>ㅁ 영역과 채우기 방식</p>
<p>o 영역 _2차원 그래픽스의 출력요소임</p>
<p>: 같은 색상값을 갖는 이웃한 픽셀들의 집합</p>
<p>-이웃한 픽셀 간의 연결방식</p>
<p>4방향 연결(상하좌우로 이웃한 픽셀들만 연결) / 8방향 연결(상하좌우&amp;&amp;대각선)
영역의 연결방식에 따라 실제 영역에 대한 판단이 달라질 수 있음</p>
<p>-레스터 영역의 경계 픽셀과 내부 픽셀은 연결방식을 다르게 함 //같은 연결 방식을 쓰면 내부와 외부가 연결되는 모순 발생</p>
<p>경계 4방향 연결-내부는 8방향 연결 채우기
경계 8방향 연결-내부는 반드시 4방향 연결 채우기
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/c788d12a-0bdf-44fd-8cb8-76b05ae91004/image.png" />
외부가 4방향 연결방식, 내부가 8방향 연결 방식이면 내부 영역 전체가 1개가 됨</p>
<p>(일반적인 래스터 방식의 출력장치에서)</p>
<p>Bresenham 선 그리기 알고리즘은 8방향연결 방식
영역채우기 알고리즘은 내부 영역을 4방향연결 방식</p>
<p>o 다각형 채우기 방식</p>
<p>(영역의 정의가 확실히 돼있어야 함)</p>
<p>-시드 채우기 방식
: 영역 내부의 한 픽셀이 시드로 주어지고, 이 걸로부터 채워나감</p>
<p>그림이 래스터 버퍼에 그려진 후, 버퍼 내의 래스터 이미지에서 영역의 채우기를 실행
재귀함수 활용한 알고리즘임</p>
<p>ex) 페인팅 sw, 대화식 이미지 처리 프로그램에서 한 픽셀을 클릭하면 영역이 칠해짐</p>
<p>(이웃 픽셀들을 찾아나갈 때, 내부 영역에 대한 판단 방식)</p>
<p>내부로 정의된 영역 채우기 == 범람채우기 flood fill //같은 값을 가지며 연결된 픽셀들을 내부영역이라고 판단
경계로 정의된 영역 채우기 == 경계채우기 boundary fill //경계의 안쪽에 위치하는 픽셀들을 내부영역이라고 판단_경계 픽셀이 나올 때까지 재귀호출
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/eb2c6f40-dafb-471d-a2e9-fc2574fc01d4/image.png" /></p>
<pre><code class="language-c">//범람 채우기 알고리즘 
void foold_fill(int x, int y){ //시드 (x,y)에서 시작 
 if(read_pixel(x,y)==bgColor){ //현재 픽셀이 배경색(같은 값)이면
  write_pixel(x,y,fillcolor); //채우기 색으로 칠함 
  flood_fill(x+1,y); //오른쪽으로 반복 / 재귀호출 
  flood_fill(x-1,y); flood_fill(x,y+1);
  flood_fill(x,y-1); } }

 //경계 채우기 알고리즘 
void boundary_fill(int x, int y){ 
 cur=read_pixel(x,y);
 if((cur!=bgColor)&amp;&amp;(cur!=fillColor)){ // !경계색 &amp;&amp; !채울색 인지 확인
  write_pixel(x,y,fillColor); //내부를 채우기 색으로 칠함
  boundary_fill(x+1,y);
  boundary_fill(x-1,y);
  boundary_fill(x,y+1);
  boundary_fill(x,y-1); } }</code></pre>
<p>다각형 주사변환 방식 == 주사선 채우기</p>
<p>: 매 주사선 별로 다각형의 내부 구간을 판단해 해당 픽셀을 칠함 (삼각형 단위) == 매 주사선에서 교차되는 edge들의 목록을 유지하고 갱신함</p>
<p>다각형을 버퍼에 그리기 전(벡터 이미지 형태)에 칠해야 하는 영역을 판단한 후, 다각형의 경계 픽셀과 내부 영역 픽셀을 동시에 그림</p>
<p>시드 채우기보다 효율적임</p>
<p>(배경지식)
여러개의 다각형이 있을 때 내부 판단해야 함</p>
<p>다각형 내부의 판단 규칙</p>
<p>-홀짝 규칙 Even-Odd Rule</p>
<p>주시선 별로 Edge가 홀수 번째 교차하면 내부가, 짝수 번째 교차하면 외부가 시작된다고 판단
//다각형이 겹쳐 있어도 겹친 부분을 항상 외부라고 판단함</p>
<p>(실제로는 구멍이 나있는 경우보다 두개가 겹쳐져 있는 경우가 더 많음)</p>
<p>-접기횟수 규칙 Non-zero Winding Rule</p>
<p>Edge를 반시계 방향으로 봄 (기본)
도형의 바깥 Edge의 방향은 반시계 방향
구멍이 나 있는 도형의 안쪽 Edge는 시계 방향
주사선 별로 아래쪽 Edge와 교차하면 접기 횟수를 1 증가, 위쪽 방향의 Edge와 교차하면 1감소
이때 접기 횟수가 0보다 큰 구간은 다각형의 내부 영역으로 판단</p>
<p>하나의 도형일 경우엔 접기횟수 규칙만 생각하면 됨
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/2b273edd-60de-4850-b02e-cb7e4e96fd81/image.png" />
볼록 다각형은 주사선 하나가 만나는 edge가 많아도 2개인데, 오목 다각형은 주사선이 만나는 edge가 많아 그리기 복잡함</p>
<p>삼각형으로는 오목 다각형을 만들 수 없음 → 다각형을 잘라 삼각형의 집합으로 만들어 다각형 주사변환 방식 적용 ⇒ 연산이 간단해짐 _n각형은 n-2개의 삼각형으로 자를 수 있음, 정삼각형에 가까울 수록 오류 안남</p>
<p>(다각형 개수는 늘어나지만 연산은 쉽고 빨라짐)</p>
<p>요즘 사용하는 2D|3D모델이 삼각형을 기반으로 함 / 벡터 방식의 그리기 sw(일러스트레이터, corel draw)에서 사용 //다각형 주사변환 방식은 항상 채우기를 하는 도형의 벡터 데이터를 갖고 있어서</p>
<p>ㅁ 문자의 표현 (문자도 출력요소 중 하나)
글자에 대한 정보는 코드(아스키,유니)</p>
<p>o 폰트의 종류</p>
<p>-래스터 폰트(Bitmap Font)
글자 크기에 해당하는 사각형 그리드의 픽셀에 1 | 0으로 글자의 모양을 표현
장점_메모리 내에서 비트맵에 대한 연산으로 처리하므로 출력 속도가 매우 빨라 제작은 용이
단점_글자의 확대,회전,밀림 등 기하변환은 매우 어려우며(확대하면 계단 현상(Aliasing)), 변환시 출력 품질 저하</p>
<p>요즘은 안씀</p>
<p>-벡터 폰트(Outline Font)
글자의 윤곽선을 여러 구간으로 나눠 직선, 원호, 곡선 등으로 표현하고, 이들에 대한 제어점을 저장해 글자 모양을 표현
MS 윈도우의 TrueType 폰트(TTF)는 2차 B-Spline 곡선(제어점을 통과하는 자연스러운 곡선/인접한 두 점 사이마다 별도의 다항식을 이용해 곡선의 정의함)을 사용
PostScript의 Type1 폰트는 3차 <strong>배지어 곡선(Bezier)</strong>을 사용 _수식만 다르고 개념은 같음</p>
<p>벡터 폰트의 처리과정:
윤곽선을 표현하는 제어점의 좌표들에 대해 축소, 회전 등 기하변환을 수행
윤곽선의 곡선 부분을 선 조각으로 나눠 윤곽을 다각형 형태로 표현
다각형 주사변환 알고리즘을 이용해 글자 내부 영역 채우기를 수행</p>
<p>장_기하변환을 해도 출력 품질이 유지됨, 기하변환이 용이 / 단_계산시간이 많이 필요
성능이 충분한 기기에서는 거의 벡터 폰트를 사용
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/866c60ae-0df5-422a-877e-369146ad9ee4/image.png" />
래스터 폰트에서 채우기 = 1이면 칠함 | 0이면 글자의 외부이므로 칠하지 않음</p>
<p>o 문자와 텍스트의 속성</p>
<p>문자: 폰트, 색상, 크기(폭과 높이), 스타일(굵은테, 밑줄…)
텍스트: 세우기 방향_Character Up 벡터로 표현 / 쓰기 방향_Text Path Direction 벡터 / 정렬(Alignment)_행간격,문자간격
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/82540d28-2d55-41f7-b26a-b6a5f5c5e5d6/image.png" /></p>
<p>ㅁ 앤티앨리어싱</p>
<p>o 래스터 출력의 문제점
앨리어싱 (신호처리 분야에서 쓰는 말)
래스터 출력장치에서 디지털화 과정의 샘플링 오차로 인한 왜곡현상
ㄴ사선의 굵기와 수평선의 굵기가 다르게 보이는 현상
ㄴ사선이나 곡선부분에 나타나는 계단 현상</p>
<p>래스터 출력장치에서 해상도가 낮을수록 픽셀 크기가 커져 계단 현상이 잘 보임
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/0244a7f7-de55-4571-9d2f-4cd8b6a407b6/image.png" /></p>
<p>o 앤티 앨리어싱 Antialiasing (AA)</p>
<p>가장 좋은 건 해상도를 높이면 됨 _GPU의 2xAA는 2배로 해상도를 높인다는 것임</p>
<p>(해상도 못 높이면)</p>
<p>컬러|회색조(Gray) 출력 장치에서 경계가 부드럽게 보이도록 하는 기법 사용</p>
<p>ㄴ물체의 경계 픽셀에서 물체와 배경의 색상을 혼합해 그림 _수퍼 샘플링 기법, 영역 샘플링 기법</p>
<p>선 그리기, 다각형 채우기, 문자 생성 등에 적용 가능
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/fdbb414b-5f61-4fdd-bf91-a27dc52fd2ce/image.png" />
해상도는 같음</p>
<p>(AA 기법)</p>
<p>-수퍼 샘플링 기법
: 하나의 픽셀 영역을 여러개로 분할하는 수퍼샘플링 과정을 적용하고, 이를 원래의 해상도로 환원할 때 픽셀의 명암값을 계산, 최종 픽셀은 원래 픽셀색상과 배경색상을 명암값에 따라 혼합해 출력(최종 픽셀의 색 농도는 명암값에 비례함)
ㄴ명암값은 하나의 원래 픽셀에 있는 고해상도 픽셀 개수에 비례함</p>
<p>단_빠르긴 한데 엄청 정밀하진 않음
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/c9cfac6d-e5cd-4192-8b4f-d2a0b63d963a/image.png" />
3xAA를 한 것임</p>
<p>-영역 샘플링 기법</p>
<p>: 다각형의 테두리에 걸치는 픽셀이 다각형의 내부영역에 얼마만큼 포함되는지 면적비율을 계산, 그 값에 따라 명암을 결정</p>
<p>ㄴ면적비율은 0과 1사이</p>
<p>Bresenham 선 그리기 알고리즘을 응용함</p>
<p>단점_정밀하긴 하지만 픽셀 하나하나마다 방정식을 풀어야해 효율이 좋지 않음 → 잘 사용하지 않음
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/27bb911e-f969-44c2-96c0-d9944322bb47/image.png" /></p>
<p>ㅁ 색상의 표현</p>
<p>o RGB 컬러 표현 방식</p>
<p>프레임버퍼에서 픽셀의 R채널, G채널, B채널에 해당 값이 저장됨
디스플레이 장치에서 표현가능한 색의 개수는 픽셀 깊이(각 픽셀을 표현하는 비트수)와 프레임 버퍼의 메모리 크기에 의해 결정
ㄴ 프레임 버퍼의 메모리 크기(B) = 해상도*픽셀 깊이
ㄴ 프레임 버퍼 크기가 고정돼 있으면 해상도에 따라 표현할 수 있는 색상의 수가 달라짐
ㄴ 픽셀의 깊이가 k 비트이면 2^k 가지 색상 표현이 가능함
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/c53d7441-de9f-42da-94ca-15373029e590/image.png" /></p>
<p>o RGBA 컬러 표현 방식</p>
<p>RGB 3가지 평면 외에 별도로 존재하는 알파 평면도 표현
알파 채널 | 알파평면 (Alpha Plane) : 투명(a=0) 및 불투명(a=1), 안개효과 등을 표현하거나, 은면 제거에 사용함
표현 가능한 색의 수는 알파 평면의 비트를 제외한 2^24 //알파 평면은 색상 정보를 표현하지 않으므로</p>
<p>o 인덱스 컬러 표현 방식</p>
<p>이미지에는 특정 계열의 색상이 많이 사용됨
사용 가능한 색상의 수가 제한될 때 사용자가 색상을 선택해 사용(사용자 정의 팔레트)-보통 그래픽스 응용 sw가 만들어줌
비슷한 색상 중 선택하면 원래 그림에 훨씬 가까운 색상으로 표현 가능
팔레트를 그림에 맞춰 메모리를 아낌</p>
<p>-색상보기표(Color Look-Up Table)</p>
<p>: ==색상 팔레트 / 사용하려는 색상을 저장하는 표
색상 보기표의 크기 = 색상 번호 개수 * 각 색상 저장에 사용하는 비트수
프레임 버퍼에는 색상 값이 아니라 색상보기표의 번호(index)를 기록함 (==픽셀에 컬러맵의 인덱스를 저장)
팔레트를 바꾸면 프레임 버퍼 내 그림의 색상도 바뀜 //단점임
각 RGB 색상의 크기가 8비트이고, 색상보기표의 크기가 256인 경우
표현 가능한 색상 2^24개(1,600만) 중 동시에 256개만 골라 사용하는 것임
프레임 버퍼의 깊이(픽셀깊이)는 8비트(색상 보기표의 인덱스 개수가 256이니까 == 2^8)
→ 각 픽셀이 24비트 대신 8비트만 저장하므로 프레임 버퍼 메모리는 1/3로 줄어듦</p>
<p>색상보기표에 필요한 메모리는 24*256 임</p>
<p><img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/358bbf32-d6dd-4ee3-bd49-81ec00656f98/image.png" /></p>
<p>요즘엔 거의 안쓰임_메모리 커져 트루컬러 씀, 예술작품에선 쓰이기도 함</p>
<h4 id="2차원-그래픽스의-변환">2차원 그래픽스의 변환</h4>
<p>(배경지식)
변환 Transform : 좌표를 바꿔 객체의 위치, 크기, 방향을 바꿈 ≠ Deformation 물체의 형태를 바꿈
// 이 교재에선 대부분 1차식으로 변환함(1차 변환) ⇒ 행렬 이용</p>
<p>-변환하는 이유 : 모델 데이터의 재사용(e.g.바퀴를 하나 모델링하고 붙여 넣음) / 계층구조의 모델(e.g.자동차가 움직이면 부품들도 다같이 움직임) / 카메라 기준|화면 기준으로 변환(e.g.사용자가 보는 방향에 따라 화면이 변함-카메라 기준으로 변환, 최종적으로 그게 화면상 어디에 위치할 것인가를 계산해야함-화면 기준으로 변환)</p>
<p>-그래픽스 파이프라인 : 연속적으로 이뤄진 좌표 변경의 과정 (e.g. 바퀴의 위치가 어떻게 바뀌는지 기록_몸체, 카메라기준, 화면 기준 등에 의해 변환이 계속됨)</p>
<p>-2차원 변환, 3차원 변환 : 변환하는 좌표가 독립적인 숫자 2개를 가지면 2차원, 3개면 3차원 변환</p>
<p>행렬
: 숫자의 모임(가로,세로)</p>
<p>-A 행렬의 i번째 행, j번째 열의 요소는 A(i,j)로 나타낼 수 있음</p>
<p>-벡터는 1열로 된 행렬</p>
<p>-덧셈, 뺄셈, 곱셈_나눗셈은 없음</p>
<p>덧셈,뺄셈은 행렬의 크기가 같아야 연산 가능</p>
<p>-행렬의 곱셈은 교환법칙이 성립X, 결합법칙 성립 _abc≠cab , (ab)c == a(bc)</p>
<p>A의 열개수와 B의 행개수가 같아야 연산 가능</p>
<p>-결과 행렬의 (i,j) 성분은 x앞에 있는 행렬의 i행과, 뒤에 있는 행렬의 j열을 곱해 더한 것임</p>
<p>ㅁ 기본적인 기하 변환</p>
<p>연산식은 오른쪽에서 왼쪽으로 씀</p>
<p>객체를 구성하는 중요한 점들을 변환하고 난 뒤 객체를 다시 그려 기하변환을 처리함</p>
<p>o 이동 Translation</p>
<p>한점 P(x,y)가 T(tx,ty)만큼 이동 → 이동된 좌표는 P’(x’,y’) 변환행렬의 크기는 1*1 _덧셈으로 표현하는 경우만</p>
<p>객체의 이동: 다각형은 각 꼭짓점, 원은 중심점을 이동해 다시 그림
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/2216fddc-2f22-4e92-b65d-74d1e87de7fe/image.png" />
o 신축 (확대/축소) Scaling</p>
<p>한 점 P(x,y)가 원점을 기준점으로 S(sx,sy)만큼 신축 //좌표 자체에 신축을 하므로 기준점을 원점으로 옮겨 신축해야함 ,안 그럼 지나치케 증감함 변환행렬의 크기는 2*2</p>
<p>신축 배율의 절댓값이 1보다 크면 객체가 확대, 절댓값이 1보다 작으면 축소됨</p>
<p>음수면 그 축에 대칭이 되는 방향으로 신축됨 e.g. (sx,sy)=(-2,-0.5) 이면 x축 대칭 방향으로 2배 확대, y축 대칭 방향으로 0.5배 축소됨</p>
<p>좌표의 신축배율이 다르면 객체의 모습까지 변함 같으면 크기만 바뀜
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/560e5003-ebdf-40ce-aedf-0dc801b79b10/image.png" />
임의의 점(x0,y0)에 대해 신축
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/71a45e53-27bf-4e73-b2d3-65247eddeaed/image.png" /></p>
<p>o 회전 Rotation</p>
<p>한 점 P(x,y) 을 원점을 기준점으로 R(θ)만큼 회전 //기준점을 원점으로 옮기고 이에 대한 회전을 해야함, 안그럼 이상한 곳으로 감
θ(회전각)이 양수이면 반시계 방향, 음수이면 시계 방향으로 회전함
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/1aa87d13-4523-4337-bfd5-3e8fe6191b04/image.png" /></p>
<p>임의의 점(x0,y0)에 대해 회전
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/81c94021-40cf-41f2-8900-32f6cb171529/image.png" /></p>
<p>ㅁ 동차좌표계를 이용한 변환</p>
<p>o 동차좌표계
-필요성
동차 좌표계를 이용해 행렬의 이동변환도 합이 아닌 곱으로 표현해 계산량을 줄이고, 연속적인 기하변환을 하나의 행렬곱으로 묶아 여러 점에 한 번에 적용하고 싶음</p>
<p>P’ = T+ P가 아닌</p>
<p>P’ = TP로</p>
<p>-표현
2차원 평면에서 한점 P(x,y)를 동차좌표계로 표현하면 차원이 하나 더 늘어나 P(x, y, h)로 표현됨
h=1이면 P(x,y,1)이 되고, 이는 2차원 좌표 P(x,y)와 같음 ⇒ 변환행렬의 크기는 3*3
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/f7eddea1-c93d-41b8-b2dc-01d92df08a6a/image.png" />
-합성변환
: 동차좌표계를 사용해 연속적인 변환행렬을 하나의 행렬로 표현한 것</p>
<p>행렬의 곱셈은 교환법칙이 성립되지 않지만 동일한 종류의 기하변환에 대해서는 교환법칙이 성립함 _회전-회전 , 신축-신축 // 특별한 경우임</p>
<p>// 결합법칙은 항상 성립
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/6dc195df-03e4-410c-9188-ebf06fd40b5a/image.png" />
합성 변환을 하는 이유: 하나의 합성 변환을 미리 계산해(gpu에 저장), 이를 수많은 점에 적용 가능</p>
<p>== 그래픽스 파이프라인을 미리 만들어 놓음
2차원 그래픽스의 변환</p>
<ul>
<li><p>반사 : 좌표의 대칭 이동
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/d9b72193-d276-452a-a29a-51b9eb7056b0/image.png" />
x축에 대한 반사변환 : Sy를 -1로 Sx는 1
y축에 대한 반사변환 : Sx를 -1로 Sy는 1
원점에 대한 반사변환 : Sx, Sy를 -1로 | 객체를 180도 회전</p>
</li>
<li><p>밀림: 객체의 한 부분을 고정시키고 다른 부분을 밂
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/23921ebd-fcd3-4227-a3a1-6f1a012ae6ad/image.png" />
// <strong>고정된 지점과의 거리와 밀리는 거리가 비례함</strong></p>
</li>
</ul>
<p>x방향으로 밀림    x’ = x + 0.5<em>y ;   //y축을 기준으로 밀림=y의 절대값에 비례해 밀림     y’=y
y방향으로 밀림    y’ = y + 0.4</em>x ;  //x축을 기준으로 밀림=x의 절대값에 비례해 밀림     x’=x</p>
<p>글자꼴 변환</p>
<p>~벡터방식에서 객체의 기하변환 _각 꼭짓점에 대해 기하변환을 함 </p>
<p><strong>레스터 변환</strong></p>
<p>==Bit Block Transfer_비트로 표현된 픽셀 블록의 이동이라는 의미
래스터 방식에서 객체의 기하변환을 할 땐 
<strong>프레임 버퍼 내 픽셀블록(픽셀들의 집합)을 직접 조작해 변환</strong>
변환이 효율적임 _<strong>수리연산 없이 비트연산으로 픽셀블록 변환함</strong></p>
<p>-래스터 연산에 사용되는 비트 연산 종류:
COPY      임시버퍼에 픽셀블록의 내용을 저장
ERASE     객체를 이동한 후 해당영역을 지움
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/18bced30-a412-43d7-a06c-b66d514ec170/image.png" />
OR          <strong>영역 복사</strong>할 때 1로 OR 연산 -픽셀값이 1 | 0 상관없이 칠함
XOR        커서 이동
AND       영역 지울 때 0으로 AND 연산_픽셀값이 1 | 0 상관없이 지움
SET          전부 1로 채움
CLEAR     전부 0으로 채움 (배경색으로 채워 잔상 없앰)</p>
<p>+래스터 그래픽스에서 객체를 임의의 각도로 회전시키는 건 어렵지만 <strong>직각</strong>으로 회전시키는 건 용이함 </p>
<p>+커서이동 
동일한 픽셀블록에 <strong>2회 연속 XOR연산</strong>을 하면 <strong>영역의 원래값이 복원됨</strong> 
배경화면의 래스터 영역을 A, 움직이는 객체(커서)의 픽셀 블록을 B라고 하면
→ <strong>A XOR B</strong> 연산으로 <strong>커서 나타남</strong>
→ 커서가 움직이면 (A XOR B)XOR B = A 가 돼 화면의 원래 모습이 복원됨
→ 새로운 위치에서 커서 객체를 <strong>A XOR B</strong> 연산으로 다시 그림 
배경화면 픽셀을 따로 보관하지 않고, 배경 손상 없이 객체를 빠르게 이동시킬 수 있음 </p>
<p><strong>윈도우와 뷰포트</strong> </p>
<p>그림에서 출력될 부분_윈도우 위치
출력장치에 디스플레이 될 위치_뷰포트 위치 </p>
<ul>
<li>뷰잉 파이프라인 (윈도우와 뷰포트의 개념)
: 객체 생성, 그림 작성, 일정 부분 출력까지의 과정 </li>
</ul>
<p><strong>2차원</strong> 그래픽스의 뷰잉 과정:</p>
<p>모델 좌표계 : 개별 객체를 정의하는 각자의 좌표계 _개별 객체의 표현과 변환이 간단 </p>
<p><strong><em>모델링 변환</em></strong></p>
<p>월드 좌표계 : 통합된 장면을 정의하는 하나의 좌표계_하나의 장면을 구성하고도 각각 모델좌표계 사용하면 비효율적임(객체 간 관계 파악X, 기하 변환 적용 비효율적)  / <strong>윈도우 설정=월드 좌표 클리핑</strong> (사용자가 원하는 부분만 출력하기 위해)</p>
<p><strong>*윈도우-뷰포트 변환 _</strong>윈도우로 설정된 영역에 대해 *****</p>
<p>뷰잉 좌표계 : 뷰포트 내의 좌표계</p>
<p><strong><em>뷰잉 좌표계의 정규화_출력장치에서 다양한 형태의 뷰포트로 쉽게 변환 가능</em></strong> </p>
<p>정규화된 뷰잉 좌표계 : 뷰잉 좌표계가 크기가 1인 정사각형 영역으로 정규화됨</p>
<p><strong><em>장치 좌표계로 변환</em>_</strong>뷰포트 영역이 출력장치의 해상도에 따라 장치좌표계로 변환됨</p>
<p>장치 좌표계 : 출력될 화면의 좌표계 / <strong>뷰포트 설정=뷰포트 클리핑</strong> (출력장치에서 <strong>출력될 위치, 크기 설정</strong>)</p>
<p><strong>뷰잉변환을 이용해</strong> </p>
<p>Zooming_뷰포트 고정,윈도우 크기 축소|확대 / Panning_윈도우 고정, 원하는 경로로 뷰포트 움직이면 카메라 각도가 돌아가는 느낌 줌<strong>(윈도우-뷰포트 변환 이용)</strong> 등 <strong>다양한 효과 가능</strong> 
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/edc82fbc-9800-4e45-9601-b737a129abd0/image.png" /></p>
<p>+윈도우-뷰포트 좌표 변환
: 윈도우 영역의 그림을 뷰포트 영역의 그림으로 기하변환
윈도우|뷰포트|화면 해상도 가 변하는 경우 윈도우-뷰포트 변환을 매번 다시 적용해야 함  </p>
<ol>
<li><strong>윈도우 영역Pw</strong>을 정규화된 뷰잉좌표계의 <strong>정규화 뷰포트Pn</strong>로 변환</li>
<li><strong>정규화 뷰포트Pn</strong>를 출력장치의 <strong>*<em>장치 좌표계의 *</em>뷰포트Pv</strong>로 변환해 처리 //최종 뷰포트
→ 윈도우-뷰포트 변환에서 양쪽의 변환이 독립적으로 이뤄지면 윈도우|뷰포트 중 <strong>하나만 변할 때 계산이 간단해짐</strong>
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/9ad93af6-30e0-49c8-aa39-278af674bc08/image.png" /></li>
</ol>
<ul>
<li>클리핑 알고리즘
: 설정된 영역 밖의 그림을 잘라냄 </li>
</ul>
<p>래스터 그래픽스는 외부 영역의 픽셀을 제거해 간단히 처리
but 벡터 그래픽스는 영역 외부의 그림을 제거하는 별도의 처리과정 수행</p>
<p>-종류</p>
<p>(클리핑을 적용하는 시점에 따라) 
월드 좌표 클리핑 / 뷰포트 클리핑 - 뭘 쓰든 상관 없지만 월드 좌표 클리핑을 사용하면 윈도우-뷰포트 변환을 수행하는 객체의 수 down → 전체 계산량 down</p>
<p>ㅁ 점 클리핑 : 래스터 그래픽스, 벡터 그래픽스_꼭짓점|끝점    에 둘 다 적용 가능
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/f50dcaab-eb8f-4eec-a2a9-05c476ddd0a7/image.png" />
ㅁ 선 클리핑: 선분과, 윈도우 영역과의 교차여부로 클리핑 여부를 판단함 
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/b990fc4e-d5b6-4961-bac8-779aaa5dc2c5/image.png" />
한 점은 윈도우 안에 있고 한점은 밖에 있거나
두 점 다 밖에 있는데 선의 일부가 안에 있으면
교점을 구해, 교점까지 잘라 살림</p>
<p>-Cohen-Sutherland 알고리즘 
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/a0ad7050-5a12-4555-aaa5-c6f81bcf26f0/image.png" />
ㅁ 영역 클리핑 : <strong>다각형 영역에 대한 판단</strong>을 해 클리핑함</p>
<p>속이 빈 다각형: 선 클리핑 알고리즘 적용</p>
<p><strong>속이 찬 다각형</strong>: 여러개의 Closed filled polygon 생성
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/26caf426-52d6-4746-b361-1591785cb474/image.png" />
+속이 찬 다각형 클리핑엔 Sutherland-Hodgman 알고리즘 적용</p>
<p>윈도우 경계 전체가 아니라 <strong>각 윈도우 경계(상하좌우)에 대해 클리핑함</strong>
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/4c039eef-849e-4d39-adcd-b68d66279316/image.png" /></p>
<p><strong>요즘은 다각형을 삼각형의 집합으로 표현해 클리핑하거나, 성능이 향상된 GPU로 다 레스터화하고 픽셀 단위로 클리핑해 위 알고리즘들을 잘 활용 X</strong></p>
<p>ㅁ 텍스트 클리핑 </p>
<p>각 글자별로 의미를 갖고 있어 단순히 영역 내 포함 여부만 판단해선 안됨 </p>
<p>-레벨:
전체 텍스트 클리핑 : <strong>텍스트</strong>가 일부만 바깥으로 나가도 전체 텍스트를 안 그림
전체 문자 클리핑 : <strong>문자</strong>의 일부가 바깥으로 나가면 문자 전체를 안 그림
개별 문자 클리핑 : <strong>픽셀</strong> 하나하나 검사해 나간 픽셀은 안 그림 = 문자를 이미지로 간주함</p>
<p><strong>정밀도, 속도에 따라</strong> 텍스트 클리핑 종류 정해 사용</p>
<h3 id="3차원-그래픽스">3차원 그래픽스</h3>
<p>: 3차원 공간상의 점, 선, 다각형, 다면체, 곡면으로 그림을 그리는 것
입력 좌표가 x,y,z 인 3차원 정보로 주어짐, 3차원 입체 공간에서 변환으로 조작
결과물을 3차원 정보로 표현
그래픽 처리 과정이 많고 복잡해 처리속도가 빠르고 복잡한 기능을 가진 그래픽스 프로세서 필요
기본적으로 벡터 그래픽스 방식을 이용해 처리함 //그래픽 처리 과정이 많고 복잡해 래스터 그래픽스 방식은 맞지 않음</p>
<p>ㅁ 처리과정 :</p>
<ol>
<li>Modeling
:3차원 좌표계에서 물체의 기하학적 형상을 표현하는 과정</li>
</ol>
<p>3차원 스캔에 의한 모델링_일반 스캐닝은 측정 대상으로부터 문자, 모양, 위치 등의 정보를 얻어내는 것인 반면, 3D스캐닝은 측정 대상으로부터 <strong>3차원 좌표 (x,y,z값)</strong>를 읽어냄</p>
<p>모델링 기법 : 와이어프레임 모델_3차원 물체의 형태를 와이어프레임(선분)으로 표현 / 다각형 표면 모델(polygon surface)_삼각형|사각형 같은 간단한 면으로 표현 / 솔리드 모델(polygon surface에 질감 더한 것)_사면체, 구 같은 기본적인 3차원 객체들의 집합으로 표현</p>
<ul>
<li>다각형 면, 2차 곡선|곡면 함수(부드러운 물체를 표현 _스플라인, Bezier, NURBS 곡선|곡면)를 이용해 3차원 객체 표현함</li>
</ul>
<p>-다각형 mesh //객체는 무엇으로 표현되든 결국 다각형 단위로 렌더링됨
<strong>삼각형 메쉬</strong> : <strong>1차 방정식</strong>으로 표현됨, 렌더링이 간단 //자주 이용 이유: 삼각형은 가장 간단한 다각형, 임의의 3 좌표가 주어지면 항상 하나의 삼각형이 유일하게 형성됨, 사각형 메쉬 처리는 계산이 복잡함 
사각형 메쉬 : 2개 삼각형으로 분할해 처리 | 평면 방정식을 근사적으로 계산</p>
<p>-기하적 데이터 표:
다면체의 기하적인 정보를 저장하는 자료구조 (꼭지점 표, 모서리 표, 다각형 표) / 일관성, 완전성 필요
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/c154a450-0485-4d8e-82d6-69ba2da579be/image.png" />
모서리 표는 별로 안 중요함 (다각형 표에서 꼭지검 순서 일관적으로 쓰면 이 정보 포함됨) → 모서리 표는 빼서 메모리 효율적으로 쓸 수 있음</p>
<p>-평면 방정식
평면 방정식(이를 만족하는 점들이 평면 위에 존재함, 좌표가 주어지면 방정식을 만족하는 평면을 구할 수 있음), 평면의 방향 (Normal Vector)
ㄴ색상,조명 계산,은면제거에 필요함</p>
<p>-2차곡선(원뿔곡선): 부드러운 곡선의 모양을 2차 방정식으로 표현 / 원뿔을 여러 각도에서 절단해 구함 
: 원 타원 포물선 </p>
<p>-2차 곡면 : 3차원 공간에서 <strong>2차 곡선에 z 성분이 확장된 것</strong> 
: 구 타원체 포물면 토러스<br />+수퍼타원 / 수퍼타원체 : 2차 곡선|곡면 방정식을 조작해 만들 수 있음</p>
<p><strong>(애니메이션)</strong></p>
<p>-<strong>스플라인 곡선</strong>: <strong>제어점</strong>을 지정해 곡선의 형태를 만듦</p>
<p>2|3차원에서 씀</p>
<p>종류:</p>
<p>(제어점으로부터 곡선을 생성하는 방법에 따라 )
보간곡선: 주어진 제어점을 모두 통과
근사곡선: 점을 다 통과하진 않고, 제어점을 연결하는 선의 모양에 근사함 
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/2c793019-6959-411e-b562-9ff31671a526/image.png" />
보간곡선은 애니메이션 e.g. 경로설정 / 근사곡선은 모델링에 사용</p>
<p>곡선의 국부제어: 제어점 하나가 바뀔 때 영향이 있는 부분이 제한됨 
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/0362419f-b981-4ebb-8799-b90c45ff042b/image.png" />
국부제어가 되는 게 좋음</p>
<p>볼록다각형 내포성: 
   볼록 다각형: 제어점을 모두 내포하는 최소 면적의 볼록한 형태의 경계
   <strong>곡선은 항상 볼록다각형 내에 포함됨</strong>
   ㄴ곡선의 개괄적인 모양을 파악, 클리핑에 이용 -점 하나하나의 위치는 몰라도 <strong>범위를 알 수 있어 유용하게 사용됨</strong>
   <strong>e.g.</strong> 객체가 움직이는 경우 만나는 부분을 간단하게 계산 가능
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/b116c9ae-e6d8-4b82-aec5-93a4092d9aee/image.png" /></p>
<p>연속성:
C0 연속성: 두 곡선이 단순히 연결돼 있는 것, 연결점에서 양쪽 곡선의 <strong>좌표값</strong>만 동일함
C1 연속성: 연결점에서 양쪽 곡선의 <strong>1차 도함수</strong>가 동일함
C2 연속성: 연결점에서 양쪽 곡선의 <strong>1차,2차 도함수가 동일</strong>해 매우 부드러운 모양의 연결된 곡선임 
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/73da5a17-b193-47b5-997e-f4f388510e08/image.png" /></p>
<p>3차 스플라인 곡선:    //실제 사용 곡선
보간 곡선임
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/f16cdd63-7045-420f-8f90-e40b6242357a/image.png" />
<strong>(모델링)</strong>
-베지어 곡선: 다항식으로 표현되는 <strong>근사곡선</strong>
<strong>제어점의 수</strong>가 <strong>베지어 다항식의 차수를 결정</strong>함 / n차 베지어 곡선은 n+1의 제어점 가짐 /
베지어 곡선의 값=제어점의 좌표값<em>배합함수 
배합함수: 곡선상 어느 한 점에서 *</em>각 제어점이 미치는 영향을 표현한 것**</p>
<p><strong>임의의 점 u값에 대해 배합함수의 합은 항상 1임</strong></p>
<p>볼록 다각형 내포성 : 베지어 곡선은 항상 제어점들로 구성된 볼록다각형 내에 위치함
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/b2f29067-507c-4899-ab84-299cd1f033ef/image.png" /></p>
<p>제어점의 중첩 : <strong>2개의 제어점을 동일한 위치에서 중첩</strong>시키면 <strong>곡선의 모양</strong>이 <strong>중첩된 제어점에 편향</strong>됨
<strong>폐곡선 | 편향된 곡선</strong>_제어점들을 같은 위치에 지정해 곡선의 모양이 그쪽으로 편향됨<br /><img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/807b9c78-cc27-4d4c-bad3-d6ce6f52b067/image.png" />
<strong>복잡한 곡선을 설계</strong>할 땐 제어점을 늘려 배합함수의 차수를 늘려 계산량 up 대신
곡선을 <strong>분할</strong>해 <strong>낮은 차수의 베지어 곡선을 연결</strong>: 
제어점을 조절해 C1. C2 연속성 만듦
곡선을 세그먼트 단위로 수정, 다른 세그먼트에는 영향을 미치지 않음 : <strong>제한적인 국부제어</strong> </p>
<p>-베지어 곡면: 베지어 곡선들을 교차시켜 <strong>제어점들을 근사하는 곡면</strong>을 만듦 / 매우 부드러운 곡면 만들 수 있음 / 베지어 곡선의 특징을 가짐 
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/7e2be379-619a-4012-b924-83e6fac55035/image.png" /></p>
<p>-B-스플라인 곡선 및 곡면: 
<strong>배합함수의 차수와, 적용구간</strong>을 <strong>*<em>곡선 설계자가 결정 가능한 *</em>근사 곡선==배합함수가 제어점의 수와 독립적</strong>
국부 제어 가능
배합함수는 연속된 벨 모양
매듭 벡터: n+d+1개 구간점의 값 / 이를 활용해 유연성 있는 곡선의 <strong>부분 설계 가능</strong>
구간 간격이 일정하면 균일 B-스플라인 곡선, 일정하지 않으면 비균일 B-스플라인 곡선 
ㄴ비균일 B-스플라인 곡선으로 유연성 있는 곡선 생성 가능 
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/96399abb-6200-43f1-b191-54ad86e44636/image.png" />
B-스플라인 곡면은 B-스플라인 배합함수의 곱으로 표현되고, B-스플라인 곡선과 같은 성질을 지님 </p>
<p>-<strong>NURBS</strong>(Non-Uniform Rational B-Spline)곡선 및 곡면: 비균일 배합함수로 정의되는 유리 B-스플라인 곡선 및 곡면
가중치, 배합함수를 조정해 여러 곡선을 만들 수 있음 
ㄴ베지어곡선, B-스플라인 곡선(분모를 1로)
볼록 다각형 내포성 가짐
매듭 벡터의 간격이 비균일함_가중치 조절해 곡선의 형태 변화 가능 
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/7d56fdc8-b33d-46e8-9a94-cf1fdc333a60/image.png" /></p>
<p>(NURBS의 차별성)
<strong>2차 곡선(</strong>원뿔 곡선) 등 <strong>대부분의 곡면 모델링 가능</strong> 
<strong>원근투영 불변성 가짐</strong> : 공간상의 NURBS 곡선을 원큰투영시키면 투영면에 나타나는 곡선도 NURBS 곡선임 (제어점을 투영시킨 후 투영면에서 곡선을 그린 것과 같음) // 분모를 가지므로 거리에 대한 계산 가능해서</p>
<p><strong>장점이 많아 상용 sw에서 제일 많이 씀</strong>
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/a9f2887e-d435-4768-91c0-674e07269eb6/image.png" /></p>
<ul>
<li><p>스위핑 기법 이용: 공간상에서 평면도형을 밀거나 회전시킴으로써 대칭적인 물체를 생성함 / 수치제어나 CAD/CAM 분야에서 이용</p>
</li>
<li><p>CSG 기법 이용(솔리드 모델링): 기본 객체에 집합 연산(합,교,차집합)을 적용해 복잡한 물체를 만듦</p>
</li>
<li><p>프랙탈 기하학 | 입자시스템 이용: 자연에서 동적으로 움직이는 물체 표현</p>
</li>
</ul>
<ol start="2">
<li>Projection (투영)
생성된 <strong>3차원 객체를 2차원 화면에 표현하기 위해, 3D 모델좌표를 2D 평면좌표로 변환하는 과정</strong> //3차원 물체가 실제로 디스플레이 되는 장치나 프린터는 2차원 출력장치이기 때문 / 자세히 말하면 물체의 빛이 투영면의 어느 부분과 만날건지 구하는 과정  / 2차원으로 바꾸므로 z좌표의 값은 0이 됨</li>
</ol>
<p>투영 기법:</p>
<ul>
<li><strong>평행 투영법</strong>_원근법 무시, <strong>투영면에 물체의 실제 크기,길이 유지</strong>
물체의 빛이 투영면에 평행하게 투영시킴 </li>
</ul>
<p>-종류</p>
<p>(투영되는 각도에 따라)
직각투영 : 
투영선과 투영면&amp;축이 직각이 되는 경우
// 물체의 길이,각도가 정확하게 표시돼 <strong>기계,건축에 적합</strong></p>
<p>임의의 점(x,y,z)를 직각투영시키면 투영면에 나타나는 투영점(xp,yp,zp)은 xp=x, yp=y, zp=0 // 2차원으로 투영해 z좌표는 0이 됨 , 계산이 간단함 </p>
<p>동축투영: 투영면이 <strong>축</strong>과 직각이 아닌 방향으로 위치함</p>
<p>경사투영: <strong>투영선</strong>이 투영면과 수직이 아니고 일정한 각도를 이룸
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/e797a0dc-f65c-4068-815b-a6190825edd0/image.png" /></p>
<ul>
<li><strong>원근 투영법</strong>_거리에 따라 크기가 다르게, 현실감 있게 투영</li>
</ul>
<p>물체의 빛이 필름을 넘어 <strong>투영중심점(시점)</strong>에 모이고, 그 중 필름과 만나는 부분이 투영면에 투영됨</p>
<p><strong>투영선들이 평행을 이루지 X, 투영면에 직각방향으로 투영되지 X</strong></p>
<p>임의의 점 P를 원근투영하면 (투영면z=0)</p>
<p> x, y는 (d-z)에 반비례 == <strong>시점에서 멀리 떨어질 수록</strong>(d-z값이 클수록) <strong>투영면에 작게 투영됨</strong> 
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/3ad9f4df-2c01-4621-b77c-2ef875a2d79c/image.png" /></p>
<ul>
<li>뷰잉 과정(파이프라인 형태):</li>
</ul>
<p>3차원 그래픽 객체의 생성부터 출력까지의 전체 과정 </p>
<p><strong>모델링 변환</strong>_모델좌표계의 3D 객체들을 <strong>월드 좌표계로 통합함</strong></p>
<p><strong>뷰잉 변환</strong>_월드좌표계에 표현된 3D 객체들을 <strong>투영변환을 쉽게 적용하기 위해</strong> 뷰잉 좌표계로 변환     </p>
<p><strong>투영 변환</strong>_뷰잉좌표계로 변환된 3D 객체들을 (정규화된 뷰볼륨 내) <strong>2차원 뷰평면에 투영 시켜 투영 좌표계로 변환함</strong> </p>
<p><strong>윈도우-뷰포트 변환</strong>_투영좌표계의 결과를 <strong>출력장치의 장치좌표계(픽셀 단위)로 나타냄</strong> </p>
<p>+<strong>뷰잉 변환(카메라 변환)</strong></p>
<p><strong>투영변환을 처리하기 위해 월드 좌표계를 뷰잉 좌표계로 변환 // 뷰잉좌표계를 사용하면 투영변환의 처리과정이 간단해짐</strong></p>
<p>ㄴ투영을 위해 뷰평면(투영면)과, 뷰볼륨(클리핑 공간), 투영방향, 투영중심점 설정에 뷰잉 좌표계 사용</p>
<p><strong>카메라 정보가 설정되면</strong>  (카메라의 위치는 원점, 바라보는 방향이 -z방향)</p>
<p><strong>뷰잉 좌표계가 결정됨</strong> //변환은 다양한 그래픽스 라이브러리(함수)가 결정 | 행렬을 직접 설정할 수도 있음
뷰평면의 기준점&amp;축 벡터&amp;법선 벡터로 설정 (뷰평면의 기준점=뷰평면의 원점, normal vector=z축,up vector: y축 (x축은 자동으로 결정됨) +투영면이 z=0인 xy 평면으로 됨 </p>
<p> <img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/6aa642ed-e900-4a20-8c68-f6e9486a26ba/image.png" /></p>
<p>-월드좌표계의 객체들을 뷰잉좌표계로 변환</p>
<p>  객체의 기하변환 대신 뷰잉좌표계 변환을 적용</p>
<p><img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/8dac650e-f59b-49f3-901f-23723bf7d924/image.png" /></p>
<p>+투영을 위한 변환</p>
<p>ㅁ뷰볼륨</p>
<p> : 투영 변환이 적용되는 3차원 공간의 영역 / 이 영역 안에 있는 객체만 뷰평면의 윈도우로 투영되고, 윈도우-뷰포트 변환을 거쳐 뷰포트로 출력됨 </p>
<p>-<strong>뷰볼륨을 직육면체 형태</strong>로 <strong>정규화</strong>해 <strong>직각투영을 이용</strong>하면 투영&amp;장치 좌표계로의 변환 용이, 투영 변환 전 클리핑이 간단해짐</p>
<p>ㄴ정규화된 뷰볼륨</p>
<p>모든 좌표가 -1~1 값의, 정육면체 형태로 표현_자르는 게 아니라 줄임 
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/24912ab0-c24d-41d5-a828-4bf0ea2959c6/image.png" /></p>
<p>ㅁ 평행투영의 경우 <strong>평행뷰볼륨</strong> </p>
<pre><code>직각투영 : 어떤 축의 방향으로 직각투영을 할떄 그 **축에 해당하는 좌표값만 0으로 바꾸면 됨** </code></pre><p>투영면이 xy평면(z=0)인 경우, 투영방향은 z축, 공간상의 점 p(x,y,z)가 직각 투영된 점은 (x,y,0)이 됨 
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/276ff363-2fa0-4f61-890b-1cf954b169c5/image.png" /></p>
<pre><code>경사투영 : 기울어진 형태의 뷰볼륨을 **직육면체 형태로 밀림 변환** 하고 직각투영 함 // 밀림변환과, 직각투영을 합성한 변환</code></pre><p>ㅁ 원근투영의 경우 <strong>프러스텀 뷰볼륨</strong></p>
<p>프러스텀을 <strong>직육면체 형태로 변환</strong>해 <strong>직각투영</strong>을 이용함</p>
<ol start="3">
<li>Rendering
:생성된 3차원 객체에 색상과 명암 변화 같은 3차원적 질감을 더해 현실감 추가하는 과정</li>
</ol>
<p>-곡면/표면 렌더링 기법: 
은면의 제거_계산량 줄임 → 면의 셰이딩_다각형면|메시의 각 점에서 빛의 반사량을 계산해 색상,명암 입힘 / 가장 오래 걸림 → 투명한 물체의 표현 → 텍스처 매핑_그림을 3차원 물체의 표면에 입힘 → 그림자 생성 →  조명 모델</p>
<p>+<strong>은면의 제거</strong>
은면제거&amp;은선제거 의 목적: 현실감 있는 그림의 생성
알고리즘 종류:</p>
<p>ㅁ객체 공간법: <strong>객체</strong>의 위치관계(앞뒤)를 이용해 은면 결정 
위치적 관계를 상호 비교해야 할 객체들의 수가 많으면 처리 시간 많이 소요됨
알고리즘의 처리 개념: </p>
<p>(객체가 가진 성질을 이용해 알고리즘 효율 up)</p>
<p>o객체의 각 표면을 투영면과의 거리에 따라 <strong>정렬(위치 이용)</strong> _깊이 정렬법에서 사용하는 접근 방식임
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/ca7bca2f-65f4-4d56-b32d-8fed4bcaab4d/image.png" />
o포함영역을 이용해 위치관계 계산 횟수 down : 포함영역 간의 겹침을 비교해(계산 간단) 중첩되면 앞뒤관계 확인<br /><img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/12fd2708-51a3-4505-93cf-42bc1cd773f7/image.png" /></p>
<p>깊이 정렬 알고리즘 (페인터 알고리즘): 다각형면을 깊이(z값)에 따라 정렬한 뒤, 먼 것부터 투영 / 뒤쪽에 있는 면은 나중에 그린 면에 가려짐 
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/2516ff4b-1f9c-47c4-8801-fbc2a38ebbc8/image.png" />
수행과정: 깊이에 따라 정렬한 뒤, 
z-영역이 겹치지 않으면 멀리 있는 면(z값 작은거)부터 그림
깊이가 겹치는 경우에는 x-영역(y-영역)에대해 검사해 겹치지 않으면 뒤에 있는거(x|y값 작은거)부터 그림
x-영역(y-영역)도 겹치면 멀리 있는 면(z-영역 비교해)부터 그림</p>
<p>ㅁ이미지 공간법: <strong>투영된 픽셀 평면</strong>에 객체가 보이는지 여부를 검사해 은면 결정</p>
<p><strong>일반적으로 공간상에 객체들이 많이, 복잡하게 존재하므로 위치 관계를 일일이 계산하는 것보단 이미지 공간법을 쓰는 게 효율적임</strong> </p>
<p><strong>z-버퍼 알고리즘</strong> (깊이 버퍼 알고리즘): <strong>카메라와 물체의 거리(z값)를 픽셀단위로 조사</strong>해 z값이 더 작은 픽셀을 그림(그냥 계속 그리다가 더 가까운거 찾으면 픽셀값을 수정) </p>
<p>z값을 저장하는 깊이버퍼<strong>(z-버퍼</strong>), 색상을 저장하는 <strong>프레임 버퍼</strong>가 필요 (해상도 같음)</p>
<p>각 객체-그 객체의 면-그 객체의 픽셀 단위로 적용하며 반복</p>
<p>⇒ 결과: z-버퍼에는 투영면에서 가장 가까운 면의 점이 , 프레임 버퍼에는 이 점의 색상값이 기록됨
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/0b6f44d9-b1c0-4401-b9f0-2eeb8ffbdda5/image.png" /></p>
<p><strong>구현이 간단</strong>하며 다각형 면에 대한 <strong>정렬이 필요 없음</strong> </p>
<p>실시간 콘텐츠에 사용</p>
<p>레이 캐스팅 기법 : 시점에서 투영면의 각 픽셀을 통해 빛(Ray)을 투사해 처음으로 만나는 객체의 픽셀을 투영
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/e4b886d2-bf7e-4a63-ace9-2050e17ebb4f/image.png" /></p>
<p>z-버퍼 알고리즘을 변형한 것임</p>
<p>ㄴ시점에서 나온 광선이 <strong>처음 만나는</strong> <strong>객체</strong>의 픽셀의 색상값만 취함 </p>
<p>수행과정:</p>
<p>광선의 벡터를 구함(U) → 광선과 객체와의 교점을 구해 가장 가까운 픽셀만 그림  </p>
<p>광선이 무엇을 만날지 사전에 몰라 <strong>z-버퍼보다 계산이 오래걸림</strong>, 교점 구하기도 어려움 → 광선 추적법의 일부로 사용 </p>
<p><strong>렌더링 등 시간이 오래걸리는 콘텐츠에 사용</strong></p>
<p>다면체 뒷면의 제거: 은면제거의 첫 단계 (객체 공간법, 이미지 공간법과 상관없이 항상 씀) / 빠르고 간단하게 뒷면을 많이 제거할 수 있음
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/c6056122-2fd3-4539-a5b9-0bb92cc48900/image.png" /></p>
<p>평면방정식 이용 : N(법선벡터)와 V(시선방향 벡터)의 곱이 0보다 크면 뒷면, 0보다 작으면 앞면으로 판단함</p>
<p>//3차원 물체 표면상의 한 점에서 색상을 구하는 방법</p>
<p>+조명 모델</p>
<p>: 광원이 어떤 식으로 객체에 빛을 반사시키고, 빛의 반사량은 얼마인지 기술하는 모델 / 물체를 보려면 <strong>광원</strong>(빛의 발광체)과 <strong>반사체</strong>가 필요</p>
<ul>
<li>조명의 종류( phong 조명 모델_근사적인 값 구함)</li>
</ul>
<p>ㅁ<strong>배경 조명</strong>: 물체의 위치에 상관없이 <strong>고르게 비춰지는 조명</strong> / 많은 <strong>산란 반사를 만듦</strong></p>
<p>ㅁ<strong>점 광원</strong>:
(점광원에 의한 산란반사와 거울반사)</p>
<p><strong>산란 반사</strong> <strong>_</strong>_빛이 모든 방향으로 고르게 반사됨 e.g. 거친 표면 </p>
<p>-<strong>총 산란 반사량</strong> = 주변 조명에 의한 산란 반사량 + 점광원에 의한 산란 반사량 
ㄴ<strong>배경 조명에 의한 산란 반사량</strong> : I = Ka<em>Ia   0&lt;Ka&lt;1   주변조명 반사 계수</em>주변조명의 밝기
ㄴ주변(배경)조명 반사 계수 == 물체의 표면이 빛을 반사하는 정도 / <strong>물체에 따라 결정됨</strong> / 빛의 반사 정도가 입사된 빛 강도보다 클 수 없음</p>
<p>ㄴ<strong>점광원에 의한 산란 반사량</strong>
-카메라(관찰자)의 위치,방향은 상관없지만, <strong>빛의 입사각, 물체와 점 광원과의 거리 에는 영향 받음 _</strong>물체의 표면이 광원에 수직으로 향하고 있을 때|점 광원과의 거리가 가까울떄 <strong>전달받는 빛 에너지의 양이 up</strong>
-Lambert의 Cosine법칙 : 표면이 받는 빛의 양은 cos세타에 비례함
<strong>cos세타</strong>=<strong>N</strong>(표면의 법선벡터)<strong>*L</strong>(광원의 방향벡터)
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/cba3fef2-6f0e-4507-ae63-7cbe0430ac1a/image.png" /></p>
<p><strong>거울 반사</strong> _<strong>빛을 받는 방향에 따라</strong> <strong>한 방향으로 많은 빛이 반사됨</strong> e.g. 매끈한 표면 / 그림자 만듦
-<strong>카메라의 위치, 방향</strong>에 영향을 많이 받음-관찰자가 반사각 부근에 위치하면 빛의 전부를 인식하게 됨 
-파이(R과 V 사이 각도)가 0도에 가까울수록==R과 V가 가까울 수록 <strong>거울 반사량 up</strong>
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/7bdcc6e1-a6fb-45c3-af78-94cf09d6ff23/image.png" />
-반짝이는 표면일수록 거울반사가 일어나는 범위가 좁음 == 거울반사량이 많음</p>
<p>-phong이 제안한 거울반사
경험적 모델: <strong>표면의 거울반사량을 계산</strong>하는 공식
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/00183194-85d2-4d6a-8df5-c37396b45e07/image.png" /></p>
<p>⇒ 총합 : Phong 조명 모델</p>
<p>ㄴ<strong>주변조명, 점광원에 의한 산란반사 &amp; 거울반사를 모두 합해</strong> <strong>표면의 한 점에서 총 밝기</strong>를 결정하는 식<br />IR / IG / IB 각각 계산됨
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/281dbcb5-dff1-49a1-b34a-be4cdb382f62/image.png" /></p>
<p><strong>반사계수</strong>(K)는 물체의 특징, <strong>광원의 세기</strong>(I)광원의 특징→<strong>이것들을 잘 조절하는 같은 물체로부터 다양한 결과를 얻을 수 있음</strong></p>
<ul>
<li>빛의 굴절과 투과:
빛은 투명한 물체의 표면을 굴절되며 투과하고, 일부는 반사됨
ㄴ반사광_투명한 물체가 반사하는 빛 / 굴절광_굴절되어 투과하는 빛
→ 빛이 굴절되므로 투명한 물체 뒤의 물체가 휘어 보임</li>
</ul>
<p>Snell 의 법칙은 입사각과 굴절각 사이에 성립하는 법칙
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/d90b72e6-1e86-4042-b84a-c00a7c8afd62/image.png" /></p>
<p>+다각형 shading 기법</p>
<p><strong>조명모델이 3차원 물체의 각 면에 적용될 때 다각형 셰이딩 기법이 필요함</strong></p>
<p>ㅁ균일 셰이딩 : <strong>각 면</strong>을 일정한 색상|명암으로 표현 </p>
<p>객체가 원래 다면체인 경우는 괜찮지만 <strong>구, 원뿔 등 원래 곡면인데 다각형으로 근사되는 객체는 현실감 down</strong></p>
<p><strong>계산 간단 but 현실감 down</strong></p>
<p>ㅁGouraud 셰이딩:  꼭짓점(V)에서의 밝기의 선형 보간으로 임의의 점의 <strong>밝기를 구함→불연속 제거</strong>
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/9f708a83-9816-48df-9c2f-12a7882290ff/image.png" /></p>
<p>각 꼭짓점의 밝기는 법선벡터로 구함, 꼭짓점에서 법선벡터는 <strong>꼭지점을 공유하는 면들의 N의 평균을임</strong>
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/f74c8134-e2e0-43c6-afae-4293f40395b6/image.png" /></p>
<p>밝기를 보간해 불연속이 생김 </p>
<p>→ 법선 벡터를 보간해 더 정밀하게 계산하자</p>
<p>ㅁPhong 셰이딩:  꼭짓점에서의 <strong>법선 벡터의 선형보간</strong>으로 임의의 점에서의 <strong>법선벡터</strong>를 구함 
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/e96b0284-77b0-4be5-ace7-64a42013e932/image.png" /></p>
<p>거울반사가 실감나게 보임 but 계산 시간이 오래걸림_모든 픽셀에서 법선 벡터의 근사치를 구해 명암&amp;밝기를 계산하므로 </p>
<p>→ 요즘은 향상된GPU가 빠르게 계산함</p>
<p>⭐<strong>내부는 부드럽게 변하는 색을 만들 수 있지만, 물체의 외각선을 부드럽게 만드는 건 아님!!</strong></p>
<ul>
<li>3차원 기하변환</li>
</ul>
<p>동차좌표계 사용해 4<em>4 변환 행렬 사용
*</em>각 꼭짓점을 변환하고, 연결해 새로 다면체를 그림** </p>
<p><strong>이동 :</strong> 
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/572cd447-cdb7-489b-8404-2808e4e94f26/image.png" /></p>
<p><strong>z축은 나를 향하는 축임</strong></p>
<p><strong>신축 : 기준점을 중심으로 객체를 확대,축소</strong>
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/3a63dc78-50c4-41d3-a014-9d592935682e/image.png" /></p>
<p><strong>회전 : 기준축을 중심으로 회전</strong> 
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/dc110844-06ce-4431-99c1-f7e6013657a0/image.png" /></p>
<p><strong>반사</strong>
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/2084c07c-d57f-4d40-875f-31bfcba4da9d/image.png" /></p>
<p>xz 평면에 대한 반사는 y 좌표값의 부호만 바뀜
원점에 대한 반사는 모든 좌표값의 부호가 바뀜</p>
<p><strong>밀림</strong></p>
<p>2차원과 마찬가지로 고정하는 점과의 거리에 비례해 밀리는 거리가 결정됨<br /><img alt="업로드중.." src="blob:https://velog.io/a70e786d-c841-44fa-a277-3cd4911305a4" /></p>
<p><strong>좌표계의 변환</strong></p>
<p>(배경지식)</p>
<p>점을 관리하려면 <strong>좌표계(기준, =좌표축+원점</strong>) 필요</p>
<p>3D 좌표계
<img alt="업로드중.." src="blob:https://velog.io/da48d3c6-f115-414d-8253-76ed41f24a94" /></p>
<p>ㅁ 객체를 고정하고 좌표계를 변환시켜도 객체를 변환시킨 것과 같은 효과  </p>
<p>-이동|회전 변환 _ 그럼 좌표계 기준에선 객체가 반대 방향(- 좌표계이동수치)으로 이동|회전한 효과
<img alt="업로드중.." src="blob:https://velog.io/bb5307d5-f1e7-4770-b6e8-457f9595dca8" /></p>
<p>-신축 변환 _ 좌표계를 확대|축소하면 객체는 축소|확대 되는 효과</p>
<p>→ 객체의 기하변환을 좌표계의 기하변환으로 나타낼 수도 있음 </p>
<p>뷰잉 과정에서 이용 : 여러 객체를 묶어 하나의 객체를 만들 때 <strong>월드 좌표계에서 배치되도록 좌표계 자체가 이동됨</strong>, 이때 각 객체의 개별적인 변환보다 <strong>좌표계변환으로 처리하는게 효율적임</strong></p>
<p>애니메이션에서 이용 : 여러 객체로 하나의 객체를 만들어 움직일 때 각 객체의 개별적인 변환보다 <strong>좌표계변환으로 처리하는게 각 부분의 움직임을 표현하는데 효율적임</strong></p>
<p>e.g. 자동차 객체 : 차체, 바퀴 모델 좌표계 → 통합된 월드 좌표계, 차체 좌표계, 바퀴 좌표계 </p>
<p>전체 자동차의 움직임은 차체 좌표계 변환 적용, 바퀴의 움직임도 좌표계 변환 적용 ⇒ 자동차를 구성하는 각 부분의 움직임을 쉽게 표현 가능</p>
<h3 id="그래픽스-이미지-처리-컴퓨터-비전-기본-이론임">그래픽스, 이미지 처리, 컴퓨터 비전 (기본 이론임)</h3>
<p>o 컴퓨터 그래픽스_인공적인 그림을 생성하는 기술_그래픽스 sw 이용 / 그림의 품질이 중요_제작 시간 up</p>
<p>입-텍스트(프로그램이나 자료구조) / 출-그림</p>
<p>o 이미지 처리_이미지를 입력받아 또다른 이미지를 만들어냄_이미지처리 sw이용 ex) 실물 사진을 디카|스캐너로 디지털화, 흑백-컬러 변환</p>
<p>입-그림(이미지) / 출-그림(이미지)</p>
<p>o 컴퓨터 비전_이미로부터 정보를 뽑음(이미지 해석)</p>
<p>입-그림 / 출-텍스트</p>
<p>+텍스트를 입력해 텍스트로 출력하는 건 기타</p>
<p>로젠펠드는 이들의 차이점(입출력형태) 구분함
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/95f7fdd3-56fa-4d2f-b20b-113c84cf8590/image.png" /></p>
<h3 id="컴퓨터-그래픽스-시스템">컴퓨터 그래픽스 시스템</h3>
<p>ㅁ구성
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/ba7d28f2-eaab-417c-961c-8509f2d2e511/image.png" />
o Graphics HW</p>
<p>Graphics processer : CPU, GPU, 그래픽스 가속기(GPU의 일부)
ㄴGPU, GPGPU</p>
<p>GPU: frame buffer에 그래픽 이미지(래스터 스캔 거쳐 픽셀 이미지 형태)를 빠르게 생성, 처리 하기 위한 프로세서 GPGPU: 수천개의 코어를 활용해 일반 병렬 처리도 함</p>
<p>래스터 스캔 시스템</p>
<p>래스터 스캔 방식(큰 개념임)
GPU가 하는 가장 큰 일 / 래스터 모니터에 적용되는 방식임_대부분의 그래픽스 프로세서가 따르는 방식
: 그래픽 프로세서가 <strong>벡터 방식으로 정의돼 있는 영상(그래픽스 명령어)</strong>을 화면에 어떻게 나타낼지를 정하는 작업</p>
<p>-스캔 변환==주사변환==레스터화
그래픽스 응용 sw가 실행됨(CPU에 의해) → 그래픽스 명령어 실행(GPU에 의해) → 처리 결과가 <strong>픽셀 이미지 형태(래스터)</strong>로 frame buffer에 저장됨_이미지의 각 픽셀 값이 저장됨</p>
<p>-주사
(프레임 버퍼에 저장된) 이미지를 위부터 스캔 라인으로 스캔해 내려가며 스캔 라인 내 각 픽셀을 개별적으로 밝혀 화면을 표시함
픽셀 → 스캔 라인 → 래스터(스캔라인의 집합)
비디오 제어기는 frame buffer 내 데이터를 초당 수십회 이상 모니터에 갱신함 / GPU 안에 있음</p>
<p>래스터 스캔 방식은 그래픽스 명령어가 변하지 않는 한, 스캔 변환을 한 번만 수행해 이미지를 프레임 버퍼에 저장하고, 스캐닝하므로 계산하며 주사하는 벡터 모니터에 비해 프로세서에 부담을 주지 않고, 속도도 빠름
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/168f8d23-791c-413c-8fac-7fd506575de6/image.png" />
memory : system memory, frame buffer</p>
<p>프레임 버퍼 : 화면에 보일 내용을 임시로 저장하는 메모리의 일부(프레임버퍼에 화면에 그릴 데이터들을 저장해 놨다가 한번에 이미지를 그림) / 지금 컴퓨터들은 그래픽스 보드 형태로 GPU와, 프레임버퍼를 가짐 / frame buffer depth(크기)는 메모리의 크기를 결정함
ㄴ프레임 버퍼로 필요한 메모리의 양(프레임 버퍼 크기)== 화면(출력장치)의 해상도와 픽셀 깊이에 비례함</p>
<p>ex) 1024768 해상도에 32비트 깊이(4B)인 경우, 1024768*4=3MB 의 용량이 필요</p>
<p>1280<em>1024 해상도의 그림이면 1280</em>1024<em>24bit(3B)=2.4MB 의 용량이 필요 1024</em>768 해상도에 1024가지의 서로 다른 색상을 동시에 디스플레이하는 경우, 1024<em>768</em>10/8 B의 용량이 필요</p>
<p>입력장치</p>
<p>(2d)
마우스(2D|3D//x,y,z) : relative 장치 //위치값이 전 위치에 영향을 받음
그래픽스 태블릿 : 핸드커서|Stylus 이용, absolute position 장치 //(x,y)좌표값 입력→정확한 좌표값을 입력해야 하는 기계설계, GIS에 이용
조이스틱 / 라이트 펜</p>
<p>(3D)
3D 디지타이저, 3D 스캐너 _3차원 물체의(x,y,z) 좌표 입력 / 디지타이저는 스타일러스를 갖다대 점 하나하나 입력, 스캐너는 레이저 빔으로 입력
모션캡처 장치 : 관절부위에 센서를 부착해 움직임 같은 동적 데이터를 실시간으로 3D좌표값으로 획득
자기적_유선 센서 / 광학적_센서로 마커를 이용, 적외선을 쪼이고 반사된 빛으로 3차원 공간에서의 위치를 파악함</p>
<p>출력장치
: 그래픽스 처리결과를 사용자에게 보여줌
하드카피 출력장치 _영구적으로 결과물 보관 가능
프린터(2D|3D) : 컬러 모니터는 CMY컬러모델 | CMYK 컬러모델
플로터_선 그리기 방식이라 벡터 이미지에 적합 (CAD, GIS 분야 같이 정교한 것을 출력할 때)</p>
<p>디스플레이 장치 _그래픽스 결과물을 상호대화식으로 생성, 수정하기 좋음 (자유로운 그래픽스 작업)</p>
<p>o CRT 모니터의 원리</p>
<p>(요새는 잘 안쓰지만 원리는 알아야 함 / 이 원리를 벡터 모니터와 래스터 모니터가 사용함)
TV의 원리와 유사하게 전자총으로부터 전자빔을 스크린에 주사
(전자빔이 스크린 화면을 주사하는 방식에 따라)</p>
<p>o 벡터 모니터
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/3e88dd3f-e88f-4c6f-8660-c79c98c6d798/image.png" />
-화소의 개념이 없음 →
장_ 앨리어스 현상 없음, 무한대의 해상도를 가짐 // 2차원 도형을 정교하게 그리기엔 좋음
-전자총이 직접 전자빔을 주사함 →
단_ CRT 모니터같이 전자총으로 라인 드로잉만 가능_라인 드로잉 앱에 적합함 , 사실적이지 않고 조명 계산 안됨(3D그래픽스에는 부적합)_랜더링 속도가 래스터 장치에 비해 매우 느림(연산을 해야 하므로)</p>
<p>o 래스터 모니터
전자총이 한줄한줄 픽셀의 위치들을 주시함
<img alt="" src="https://velog.velcdn.com/images/kimlj0814/post/4264fd97-7cec-4332-88b4-92f209f396ff/image.png" />
오늘날 대부분의 Display monitor는 래스터 스캔방식임
사실적인 표현에 적합(shading,coloring)
앨리어싱 발생 : 직선이 지그재그 모양으로 디스플레이됨 _앤티앨리어싱 필요함</p>
<p>o 컬러 모니터</p>
<p>(컬러 모니터의 원리를 각 모니터가 사용하는 방식)
벡터 모니터_빔주사 방식 / 래스터 모니터_섀도우 마스크 방식(전자총이 동시에 R,G,B 전자빔을 스크린에 주사)</p>
<p>o 평판 디스플레이 장치</p>
<p>CRT모니터보다 두께가 얇음
액정 디스플레이 장치(LCD), LED, OLED _래스터 모니터에 속함(프레임 버퍼 이용)</p>
<p>o Graphics program(sw)</p>
<p>-그래픽스 라이브러리 :</p>
<p>==그래픽스 API_Application Program Interface : GPU에게 명령을 시킬 수 있는 것들의 집합 / 그래픽스 명령어가 표준화돼 있어 그래픽스 응용 프로그램의 호환성 생김(그래픽스hw에 독립적임) / 함수라고 생각하자
기능 : 그래픽 객체의 모델링, 기하 변환, 랜더링, 애니메이션…</p>
<p>(컴퓨터 그래픽스 표준==API 표준)
OpenGL : 컴과 폰에 범용으로 쓸 수 있음 -Direct3D는 컴만 사용 가능
JAVA 3D : 자바 언어에 3D 추가한 것
WebGL : 대부분의 웹 브라우저에서 실행되는 2,3차원 그래픽스를 지원하는 JAVA Script API를 제공함</p>
<p>그래픽스 응용 프로그램
그래픽 데이터를 생성, 처리하고, 그래픽 결과를 디스플레이 하기 위해서 필요함</p>
<p>일반적으로 그래픽스 라이브러리(그래픽스 API)를 이용해 개발 //그래픽스 프로그램을 일일이 개발하면 비용이 너무 많이 필요</p>
<p>→ 그래픽스 응용 프로그램이 그래픽스 라이브러리를 호출하고, 호출된 라이브러리는 그래픽스 하드웨어에게 명령을 내림</p>
<p>o Grapics Database</p>
<p>: 2차원 | 3차원 물체, 주변환경을 기술하는 데이터</p>
<p><strong>컴퓨터 그래픽스의 활용</strong></p>
<p>ㅁ CAD
사용 분야: 부품설계 및 도면작성(Drafting), 기계설계, 전자회로 설계, 건축 설계 (컴퓨터를 이용한 설계)
사용자는 CAD의 구체적 활용영역에 따라 특화된 CAD sw 이용함</p>
<p>ㅁ 애니메이션
일련의 정지된 그림이나 이미지(프레임)를 연속으로(초당 15 프레임 이상) 보여줘 연속된 동작으로 느끼게 함 (인간의 잔상효과 이용)</p>
<p>ㅁ 가상현실
3차원 세계를 표현한 후, 관찰자의 시점,움직임 같은 입력 데이터에 따라 실시간으로 3차원 세계를 재구성함
가상공간을 빠르개 구성해 디스플레이(초당 15프레임 이상)하는게 중요→매우 빠른 프로세서 필요 시뮬레이션: 교육,훈련 분야에서 많이 쓰임, 사용자의 입력 데이터 | 입력 파라미터에 따라 디스플레이 되는 장면이 변함</p>
<p>ex) 비행 시뮬레이터</p>
<p>메타버스 : 현실세계를 반영한 가상의 3차원 공간을 그래픽으로 표현</p>
<p>공통점 : 다 컴퓨터 그래픽스 기술 활용해 그림을 만듦 / 동적으로 움직이는 그림을 화면에 연속으로 디스플레이함</p>
<p>ㅁ 컴퓨터 디자인, 아트
상업 디자인, 창작 미술</p>
<p>ㅁ 게임 및 엔터테이먼트</p>
<p>ㅁ 멀티미디어 분야
웹페이지, 디지털 방송, 사이버 클래스</p>
<p>ㅁ 프리젠테이션 및 데이터시각화
프리젠테이션 그래픽스 : 그래프, 차트…</p>
<p>ㅁ GUI
윈도우, 아이콘, 메뉴</p>
<p>ㅁ 전자출판 Desk-Top Publishing
탁상출판 sw를 이용하면 출판물 생성, 수정을 효과적으로 할 수 있음</p>
<p>ㅁ 공간정보의 표현
지리정보시스템(GIS) : 공간정보를 2|3차원 그래픽스로 표현해 교통, 환경, 도시 계획 등의 분야에서 합리적 의사결정 도움
ex) Car Navigation System(GPS로 차량의 현재 위치 인식함)은 교통정보를 실시간으로 입력받아 사용자에게 바람직한 주행경로를 그래픽스 형태로 디스플레이 해 줌
Military,Police,Emergency monitoring</p>
<p>ㅁ 이미지 처리
컴퓨터 그래픽스 분야와 다른 영역이지만,
동일한 알고리즘|기법 사용하기도 하고, 결합돼 이용되는 경우 많음 ex) 의료 영상처리 기기가 분석한 이미지에 그래픽스 기술을 이용해 다른 그림을 합성해 디스플레이
이미지 처리에는 입력된 이미지를 컴퓨터가 이해하기 쉽게 바꾸는 것도 포함됨 (컴퓨터 비전 전 단계라고 생각하자)</p>
<p>: 문자 인식 , 패턴 인식, 의료 영상처리(e.g. MRI, CT)</p>
<p>ex) 패턴인식 - 카메라가 포착한 자동차 번호판 이미지를 처리,분석해 번호를 자동적으로 인식하게 도움</p>